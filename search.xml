<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Mybatis一级缓存和二级缓存</title>
      <link href="/Mybatis%E4%B8%80%E7%BA%A7%E7%BC%93%E5%AD%98%E5%92%8C%E4%BA%8C%E7%BA%A7%E7%BC%93%E5%AD%98.html"/>
      <url>/Mybatis%E4%B8%80%E7%BA%A7%E7%BC%93%E5%AD%98%E5%92%8C%E4%BA%8C%E7%BA%A7%E7%BC%93%E5%AD%98.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>广度优先遍历(BFS)和深度优先遍历（DFS）</title>
      <link href="/%E5%B9%BF%E5%BA%A6%E4%BC%98%E5%85%88%E9%81%8D%E5%8E%86-BFS-%E5%92%8C%E6%B7%B1%E5%BA%A6%E4%BC%98%E5%85%88%E9%81%8D%E5%8E%86%EF%BC%88DFS%EF%BC%89.html"/>
      <url>/%E5%B9%BF%E5%BA%A6%E4%BC%98%E5%85%88%E9%81%8D%E5%8E%86-BFS-%E5%92%8C%E6%B7%B1%E5%BA%A6%E4%BC%98%E5%85%88%E9%81%8D%E5%8E%86%EF%BC%88DFS%EF%BC%89.html</url>
      
        <content type="html"><![CDATA[<h4 id="是什么？"><a href="#是什么？" class="headerlink" title="是什么？"></a>是什么？</h4><blockquote><p><strong>深度优先搜索算法</strong>（英语：Depth-First-Search，DFS）是一种用于遍历或搜索树或图的算法。这个算法会尽可能深的搜索树的分支。当节点v的所在边都己被探寻过，搜索将回溯到发现节点v的那条边的起始节点。这一过程一直进行到已发现从源节点可达的所有节点为止。如果还存在未被发现的节点，则选择其中一个作为源节点并重复以上过程，整个进程反复进行直到所有节点都被访问为止。<a href="https://zh.wikipedia.org/wiki/深度优先搜索#cite_note-ItoA-1" target="_blank" rel="noopener">[1]</a>(p603)这种算法不会根据图的结构等信息调整执行策略</p></blockquote><blockquote><p><strong>广度优先搜索算法</strong>（英语：Breadth-First Search，缩写为BFS），又译作<strong>宽度优先搜索</strong>，或<strong>横向优先搜索</strong>，是一种图形搜索算法。简单的说，BFS是从根节点开始，沿着树的宽度遍历树的节点。如果所有节点均被访问，则算法中止。</p></blockquote><p>来自维基百科</p><h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><p><img src="/广度优先遍历-BFS-和深度优先遍历（DFS）/TIM图片20200401165344.png" alt></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * @author CongZ</span><br><span class="line"> * @classname DFSandBFS</span><br><span class="line"> * DFS Depth First Search 深度优先算法</span><br><span class="line"> * BFS Breadth FirstSearch 广度优先算法</span><br><span class="line"> * @create 2020/3/31</span><br><span class="line"> **/</span><br><span class="line"></span><br><span class="line">public class DFSandBFS &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        TreeNode head = new TreeNode(1);</span><br><span class="line">        TreeNode two = new TreeNode(2);</span><br><span class="line">        TreeNode three = new TreeNode(3);</span><br><span class="line">        TreeNode four = new TreeNode(4);</span><br><span class="line">        TreeNode five = new TreeNode(5);</span><br><span class="line">        TreeNode six = new TreeNode(6);</span><br><span class="line">        TreeNode seven = new TreeNode(7);</span><br><span class="line">        TreeNode eight = new TreeNode(8);</span><br><span class="line">        head.left = two;</span><br><span class="line">        head.right = three;</span><br><span class="line">        two.left = four;</span><br><span class="line">        two.right = five;</span><br><span class="line">        three.left = six;</span><br><span class="line">        three.right = seven;</span><br><span class="line">        four.right=eight;</span><br><span class="line">        System.out.print(&quot;广度优先遍历结果：&quot;);</span><br><span class="line">        System.out.println();</span><br><span class="line">        new DFSandBFS().BFS(head);</span><br><span class="line">        System.out.println();</span><br><span class="line">        System.out.print(&quot;深度优先遍历结果：&quot;);</span><br><span class="line">        System.out.println();</span><br><span class="line">        new DFSandBFS().DFS(head);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 广度优先</span><br><span class="line">     * @param headNode</span><br><span class="line">     */</span><br><span class="line">    public void BFS(TreeNode headNode) &#123;</span><br><span class="line">        if (headNode == null) &#123;</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        Queue&lt;TreeNode&gt; queue = new LinkedList&lt;&gt;();</span><br><span class="line">        queue.add(headNode);</span><br><span class="line">        while (!queue.isEmpty()) &#123;</span><br><span class="line">            TreeNode node = queue.poll();</span><br><span class="line">            System.out.print(node.node+&quot;,&quot;);</span><br><span class="line">            if (null != node.left) &#123;</span><br><span class="line">                queue.add(node.left);</span><br><span class="line">            &#125;</span><br><span class="line">            if (null != node.right) &#123;</span><br><span class="line">                queue.add(node.right);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 深度优先</span><br><span class="line">     * @param headNode</span><br><span class="line">     */</span><br><span class="line">    public void DFS(TreeNode headNode)&#123;</span><br><span class="line">        if(headNode !=null)&#123;</span><br><span class="line">            Stack&lt;TreeNode&gt;stack=new Stack&lt;&gt;();</span><br><span class="line">            stack.add(headNode);</span><br><span class="line">            while(!stack.isEmpty())&#123;</span><br><span class="line">                TreeNode node=stack.pop();</span><br><span class="line">                System.out.print(node.node+&quot;,&quot;);</span><br><span class="line">                if(node.right!=null)&#123;</span><br><span class="line">                    stack.push(node.right);</span><br><span class="line">                &#125;</span><br><span class="line">                if(node.left!=null)&#123;</span><br><span class="line">                    stack.push(node.left);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    static class TreeNode &#123;</span><br><span class="line">        int node;</span><br><span class="line">        TreeNode left;</span><br><span class="line">        TreeNode right;</span><br><span class="line"></span><br><span class="line">        public TreeNode(int data) &#123;</span><br><span class="line">            node = data;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">广度优先遍历结果：</span><br><span class="line">1,2,3,4,5,6,7,8,</span><br><span class="line">深度优先遍历结果：</span><br><span class="line">1,2,4,8,5,3,6,7,</span><br></pre></td></tr></table></figure><p>广度优先遍历利用的是队列的<strong>先进先出</strong>特性</p><p>步骤：</p><p>1、获取到根节点1 ，判断根节点是否有子节点，如果有，添加到队列</p><p>2、移除根节点1，剩下节点2和节点3</p><p>3、移除节点2，判断节点2是否有子节点，添加到队列节点4和节点5 ，剩下节点3和节点4和节点5</p><p>4、依次移除节点3，判断节点3是否有子节点，添加到队列节点6和节点7，剩下节点4,5,6,7</p><p>5、依次循环，直到判断所有子节点为空</p><p>深度优先遍历利用的是栈的<strong>先进后出</strong>特性</p><p>步骤：</p><p>1、获取根节点1，判断根节点是否有子节点，如果有，添加到栈</p><p>2、移除根节点1，剩下节点2和节点3</p><p>3、移除节点2，判断节点2，是否有子节点，添加到队列，节点4,5，剩下节点3,4,5</p><p>4、这里有点区别就是，移除的是节点4，因为节点4是最后进栈的，所以最先出去，剩下节点3,5</p><p>5、移除节点5，判断是否有子节点，剩下节点3</p><p>6、依次循环，直到判断所有子节点为空</p><p>深度遍历（DFS）又分为三种</p><p>前序遍历，后序遍历，中序遍历，上面的代码指的是中序遍历</p>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JAVA，算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Redis总结</title>
      <link href="/Redis%E6%80%BB%E7%BB%93.html"/>
      <url>/Redis%E6%80%BB%E7%BB%93.html</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>Redis也用了好久，一直没有详细的做一个整理，也没有看看文档，基本就是拿来就用，在之前的文章中，也谈到过Redis对性能的影响，也用过Redis做缓存相关的设计来提升系统性能。这两天休息，就来整理一下</p><p>我看到官方文档上的资料挺全的，我就不去看那些二手知识了，直接看文档，整理一下。</p><h1 id="开始"><a href="#开始" class="headerlink" title="开始"></a>开始</h1><h2 id="是什么？"><a href="#是什么？" class="headerlink" title="是什么？"></a>是什么？</h2><p>Redis是一个开源的非关系型的key-value数据库，支持丰富的数据类型，List，Set，ZSet，Hash，String。平常可以用来做数据缓存，消息队列，分布式锁等场景。</p><h2 id="文档"><a href="#文档" class="headerlink" title="文档"></a>文档</h2><p>跟着文档的节奏来整理一下知识点</p><h3 id="Redis持久化"><a href="#Redis持久化" class="headerlink" title="Redis持久化"></a>Redis持久化</h3><p>Redis提供了不同级别的持久化方式：</p><p>RDB:在指定的时间间隔对数据进行快照存储</p><p>AOF:记录每次对服务器的写操作，当服务器重启时，重新执行这些命令来恢复数据，AOF命令以redis协议追加保存到文件末尾，redis还能对AOF文件进行重写，比如+1操作，加十次，合并为一条+10，以此来减少文件体积</p><p>如果只想保证数据在运行的时候存在，也可不指定持久化方式</p><p>通常做法是开启两个持久化方式，如果机器在断点之后，使用RDB来恢复大部分数据，然后在使用AOF来恢复最后剩下的未备份的数据，这样就能保证数据的完整性</p><h4 id="RDB"><a href="#RDB" class="headerlink" title="RDB"></a>RDB</h4><h5 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h5><p>RDB是一个紧凑的单一文件，方便保存，方便传送到远端数据中心来防止数据丢失。RDB在保存RDB文件时，父进程唯一需要做的就是fork一个子进程，然后父进程就不需要做其他I/O操作，全部由子进程来完成备份工作，所以RDB的持久化方式可以最大化redis的性能</p><h5 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h5><p>就是上文说的，可能备份之后，下次备份之前，机器断电，中间的数据就丢失了。</p><p>RDB需要经常fork子进程来保存数据到磁盘上，当数据比较大的时候，fork的过程非常耗时，可能会导致redis在一些毫秒级内不能响应客户端的请求，如果数据集特别大，CPU性能不是很好的时候，这种情况会持续1s。</p><h5 id="快照"><a href="#快照" class="headerlink" title="快照"></a>快照</h5><p>Redis将数据库快照保存在名字为dump.rdb的二进制文件中，可以对redis进行设置，让他在N秒内数据集至少有M个改动这一个条件满足时，自动保存一次数据，也可以通过SAVE或者BGSAVE手动让redis进行数据集保存操作</p><p>60秒内至少有1000个改动 就会自动保存一次数据集</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">save 60 1000</span><br></pre></td></tr></table></figure><h5 id="工作方式"><a href="#工作方式" class="headerlink" title="工作方式"></a>工作方式</h5><p>当redis需要保存dump.rdb文件时，服务器执行以下操作</p><p>1、redis调用forks，同时拥有父进程和子进程。</p><p>2、子进程将数据集写入到一个临时的RDB文件中。</p><p>3、当子进程完成对新RDB文件的写入，redis用新的RDB文件替换原来的RDB文件，并删除旧的RDB文件</p><p>这种工作方式使redis可以写时复制（copy-on-write）机制中获益</p><h4 id="AOF"><a href="#AOF" class="headerlink" title="AOF"></a>AOF</h4><h5 id="优点-1"><a href="#优点-1" class="headerlink" title="优点"></a>优点</h5><p>使用AOF会让redis更加耐久，可以使用不同的同步fsync策略:无fsync,每秒fsync,每次写入的时候fsync。使用默认的每秒fsync,redis的性能依然很好（fsync是由后台线程进行处理，主线程会尽力处理客户端的请求），一旦出现故障，最多丢失一秒的请求。</p><p>redis可以在AOF文件体积过大的时候，自动在后台对AOF重写合并，重写操作是绝对安全的，因为redis在创建新的AOF文件时，会继续将命令追加到现有的AOF文件中，即时重写时发生停机，现有的AOF文件也不会丢失，而新AOF文件创建完之后，redis就会从就的AOF文件切换到新的AOF文件，并开始对新的AOF文件做追加操作</p><h5 id="缺点-1"><a href="#缺点-1" class="headerlink" title="缺点"></a>缺点</h5><p>对于相同数据集来说，AOF文件的体积通常大于RDB文件的体积</p><p>根据所有的fsync策略，AOF的速度可能比RDB慢</p><h5 id="工作方式-1"><a href="#工作方式-1" class="headerlink" title="工作方式"></a>工作方式</h5><p>只追加操作的文件（Append-only file,AOF）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">appendonly yes</span><br></pre></td></tr></table></figure><p>AOF和RDB都运用了写时复制机制</p><p>1、redis执行fork()，现在同时拥有父进程和子进程</p><p>2、子进程开始将新的AOF文件的内容写入到临时文件。</p><p>3、对于新执行的写入命令，父进程一边将他们累计到内存缓存中，一边将这些改动追加到AOF文件的末尾，这样，即时在重写中途发生停机，现有的AOF文件也是安全</p><p>4、当子进程完成工作，会给父进程发一个信号，父进程接收到信号之后，将内存缓存中的所有数据追加到新的AOF文件末尾</p><p>5、redis原子地用新文件替换就文件，之后所有的命令都会追加到新文件的末尾</p><h5 id="日志重写"><a href="#日志重写" class="headerlink" title="日志重写"></a>日志重写</h5><p>上文提到过日志重写，即合并指令。可以在不打断服务客户端的情况下，对AOF文件重建（rebuild）。执行bgrewriteaof,redis将生成一个新的AOF文件，这个文件保存了重建当前数据集的最少命令，redis2.2需要手动执行，redis2.4可以自动触发AOF重写</p><p>使用redis-check-aof对原来的AOF文件修复</p><h4 id="备份"><a href="#备份" class="headerlink" title="备份"></a>备份</h4><p>可以将RDB文件上传到数据中心之外的远程服务器上，比如S3</p><h3 id="Redis的Sentinel-哨兵"><a href="#Redis的Sentinel-哨兵" class="headerlink" title="Redis的Sentinel(哨兵)"></a>Redis的Sentinel(哨兵)</h3><p>Redis的Sentinel用来管理多个Redis的服务器，系统执行三个任务</p><p>1、监控（Montioring）:不断检查服务器和从服务器是否正常</p><p>2、提醒（Notification）:当某个Redis服务器出问题，可以通过API向管理员或其他应用程序发送通知</p><p>3、自动故障迁移（Automatic failover）:当主服务器不能正常工作，Sentinel会开始自动故障迁移，将失效的主服务器的其中一台从服务器升级为新的主服务器，让失效的主服务器的从服务器改为复制新的主服务器，当客户端试图连接失效服务器时，集群也会向客户端返回新的主服务器地址</p><h4 id="主观下线和客观下线"><a href="#主观下线和客观下线" class="headerlink" title="主观下线和客观下线"></a>主观下线和客观下线</h4><p>Redis中的Sentinel关于下线（down）有两个概念</p><p><strong>主观下线（SDOWN）</strong>指单个Sentinel实例对服务器做出的下线判断</p><p><strong>客观下线（ODOWN）</strong>指多个Sentinel实例在对同一个服务器做SDOWN判断，并且通过 SENTINEL is-master-down-by-addr 命令互相交流之后， 得出的服务器下线判断。</p><p>下线的判断为Sentinel去PING服务器，如果指定时间没有回复，则判断下线</p><h4 id="故障转移"><a href="#故障转移" class="headerlink" title="故障转移"></a>故障转移</h4><p>一次故障转移操作由以下步骤组成：</p><ul><li><p>发现主服务器已经进入客观下线状态。</p></li><li><p>对我们的当前纪元进行自增（详情请参考 Raft leader election ）， 并尝试在这个纪元中当选。</p></li><li><p>如果当选失败， 那么在设定的故障迁移超时时间的两倍之后， 重新尝试当选。 如果当选成功， 那么执行以下步骤。</p></li><li><p>选出一个从服务器，并将它升级为主服务器。</p></li><li><p>向被选中的从服务器发送 <code>SLAVEOF NO ONE</code> 命令，让它转变为主服务器。</p></li><li><p>通过发布与订阅功能， 将更新后的配置传播给所有其他 Sentinel ， 其他 Sentinel 对它们自己的配置进行更新。</p></li><li><p>向已下线主服务器的从服务器发送 SLAVEOF命令， 让它们去复制新的主服务器。</p></li><li><p>当所有从服务器都已经开始复制新的主服务器时， 领头 Sentinel 终止这次故障迁移操作。</p><h5 id="Sentinel选择新主服务器规则"><a href="#Sentinel选择新主服务器规则" class="headerlink" title="Sentinel选择新主服务器规则"></a>Sentinel选择新主服务器规则</h5><p>排除掉主观下线，以断线，或者最后一个PING大于5秒的</p><p>排除与主服务器断开连接超过down-after指定时长的十倍</p><p>剩下的从服务器使用复制偏移量最大的作为主服务器，如果复制偏移量不够，则选最小运行ID的作为主服务器</p></li></ul>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>看看JAVA线程池</title>
      <link href="/%E7%9C%8B%E7%9C%8BJAVA%E7%BA%BF%E7%A8%8B%E6%B1%A0.html"/>
      <url>/%E7%9C%8B%E7%9C%8BJAVA%E7%BA%BF%E7%A8%8B%E6%B1%A0.html</url>
      
        <content type="html"><![CDATA[<h4 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h4><p>这偏文章想写好久了，也经常会去看看线程池方面的东西，但是感觉都好杂，一百个人有一百个人的线程池，这是我的理解，所以在我看来很难接受，所以现在写这篇文章，是想自己整理一下。</p><h4 id="起源"><a href="#起源" class="headerlink" title="起源"></a>起源</h4><p>起源是来自阿里巴巴的开发规范其中的两点，这里引用一下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">1、线程资源必须通过线程池提供，不允许在应用中自行显示创建线程</span><br><span class="line">说明：线程池的好处是减少在创建和销毁线程上所消耗的时间以及系统资源的开销，解决资源不足的问题，如果不使用线程池，有可能造成系统创建大量同类线程而导致消耗完内存或者“过度切换”的问题</span><br><span class="line">2、线程池不允许使用Executors去创建，而是通过ThreadPoolExecutor的方式，这样的处理方式让写的同学更加明确线程池的运行规则，规避资源耗尽的风险</span><br><span class="line">说明：Executors返回的线程池对象的弊端如下:</span><br><span class="line">1) FixedThreadPool和SingleThreadPool:</span><br><span class="line">允许的请求队列长度为Integer.MAX_VALUE,可能会堆积大量的请求，从而导致OOM</span><br><span class="line">2) CachedThradPool:</span><br><span class="line">允许的请求队列长度为Integer.MAX_VALUE,可能会堆积大量的请求，从而导致OOM</span><br></pre></td></tr></table></figure><p>这是我开始看看线程池的起源，之前也用到过，但也只是局限于用过，没有深入的了解一下各个参数的意义，好了，来看看。</p><h4 id="开始"><a href="#开始" class="headerlink" title="开始"></a>开始</h4><p>先看看为什么用Executors会导致OOM吧</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Executor executor=Executors.newFixedThreadPool(<span class="number">10</span>);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">newFixedThreadPool</span><span class="params">(<span class="keyword">int</span> nThreads)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ThreadPoolExecutor(nThreads, nThreads,</span><br><span class="line">                                      <span class="number">0L</span>, TimeUnit.MILLISECONDS,</span><br><span class="line">                                      <span class="keyword">new</span> LinkedBlockingQueue&lt;Runnable&gt;());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">LinkedBlockingQueue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>(Integer.MAX_VALUE);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到在是用Executors创建线程池的时候会去实例化一个ThreadPoolExecutor 然后指定的等待度列里面设置的值为Integer.MAX_VALUE,如果系统长时间运行，就会堆积大量的请求，从而导致OOM</p><p>在来看看正确的打开方式，上代码</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line">    * 设置核心池大小</span><br><span class="line">    */</span><br><span class="line">   int corePoolSize = 20;</span><br><span class="line">   /**</span><br><span class="line">    * 设置线程池最大能接受多少线程</span><br><span class="line">    */</span><br><span class="line">   int maximumPoolSize = 100;</span><br><span class="line">   /**</span><br><span class="line">    * 当前线程数大于corePoolSize、小于maximumPoolSize时，超出corePoolSize的线程数的生命周期</span><br><span class="line">    */</span><br><span class="line">   long keepActiveTime = 200;</span><br><span class="line">   /**</span><br><span class="line">    * 设置时间单位，秒</span><br><span class="line">    */</span><br><span class="line">   TimeUnit timeUnit = TimeUnit.SECONDS;</span><br><span class="line">   /**</span><br><span class="line">    * 设置线程池缓存队列的排队策略为FIFO，并且指定缓存队列大小为5</span><br><span class="line">    */</span><br><span class="line">   BlockingQueue&lt;Runnable&gt; workQueue = new ArrayBlockingQueue&lt;Runnable&gt;(5);</span><br><span class="line">   /**</span><br><span class="line">    * 创建ThreadPoolExecutor线程池对象，并初始化该对象的各种参数</span><br><span class="line">    */</span><br><span class="line">   @SuppressWarnings(&quot;AlibabaThreadShouldSetName&quot;)</span><br><span class="line">   ThreadPoolExecutor executor = new ThreadPoolExecutor(corePoolSize, maximumPoolSize, keepActiveTime, timeUnit, workQueue);</span><br></pre></td></tr></table></figure><p>这是我在项目里面创建的一个线程，目的是接收MQ发过来的消息，由于不确定上游的流量有多少，这里会使用这个线程池</p><p>先来解释一下各个参数：</p><p><strong>corePoolSize  核心线程数</strong> 核心线程会一直存在，当线程数小于核心线程，并且有线程空闲，它也会创建一个新线程去处理</p><p><strong>maximumPoolSize  最大线程数</strong> 允许当前线程池创建多少线程 ,如果当前线程数量大于核心线程数量 ，并且等待队列已满，则会去创建新的线程去处理</p><p><strong>keepAliveTime 等待时间</strong>当空闲线程达到这个时间时会退出，直到线程数=核心线程数时</p><p><strong>unit 单位</strong>单位，就没什么解释的，等待时间的单位</p><p><strong>workQueue 工作队列</strong>  当线程数大于核心线程数时，就会将当前线程放到等待队列中去。</p><p>未完待续。。。</p>]]></content>
      
      
      <categories>
          
          <category> JAVA </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JAVA，线程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Mysql索引</title>
      <link href="/Mysql%E7%B4%A2%E5%BC%95.html"/>
      <url>/Mysql%E7%B4%A2%E5%BC%95.html</url>
      
        <content type="html"><![CDATA[<h4 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h4><p>今天一大堆事等着做，这期需求就5天时间，一个全新的功能要上，今天不算时间，要过评审，要设计表结构，此时的我正在等待拉新分支，然后疯狂输出。</p><p>刚刚看有道云笔记，发现我之前写过关于Mysql索引的文章，我都快忘记了，现在重温一下，整理到博客中。</p><h4 id="开始"><a href="#开始" class="headerlink" title="开始"></a>开始</h4><p>在项目中，我常听到加索引啊，走索引啊，你这样写，是全表扫，没走索引，你这索引失效了等等一大堆的，围绕的一个点都是索引，关于SQL优化，在日常中就是让这个sql去走索引查询，所以今天就来看看索引到底什么。</p><h4 id="是什么"><a href="#是什么" class="headerlink" title="是什么"></a>是什么</h4><p>简单来说，索引就是让我们查询更快，能更快的找到想要的值，避免去全表扫描，从而优化查询性能。就这么简单。</p><p>但是如果说添加的索引多了，则会降低修改这个表的速度，因为当表里面新增或修改了数据，就需要去维护索引，从而导致耗时，还有索引文件也是会占用空间，如果数据量很大，会导致索引文件大小达到上限。</p><h4 id="怎么建"><a href="#怎么建" class="headerlink" title="怎么建"></a>怎么建</h4><p>上面说了，索引并不是越多越好，而是要在合适的字段上面去建立合适的索引，所以就有一些原则：</p><p>1、对经常更新的表，尽量少建索引，只对经常查询的字段去建索引。</p><p>2、对数据量小的表最好不要使用索引，因为数据比较少，可能查询全部数据的耗时和查找索引的时间还要短，所以就没有多大意义</p><p>3、在区别度不大的字段上不要建立索引，比如性别，类型。</p><p>上面说了不适合建索引的，下面在来看看哪些情况需要建索引 <strong>往往不需要自己主动建索引，一般在DBA发现性能问题出报告后，才会根据SQL去建立合适的索引</strong></p><p>1、主键，自动建立唯一索引</p><p>2、频繁作为查询条件的字段</p><p>3、频繁和其他表关联的字段，比如外键</p><p>4、排序字段，比如create_time等，建立索引会对排序的数据有很大的提高</p><p>5、查询统计字段或分组字段</p><h4 id="到底是什么"><a href="#到底是什么" class="headerlink" title="到底是什么"></a>到底是什么</h4><p>Mysq的InnoDB存储引擎支持B Tree索引，全文索引，Hash索引，但是InnoDB存储引擎支持的是Hash索引自适应的，InnoDB存储引擎会根据表的使用情况自动为表生成Hash索引，不能人为干预是否在一张表中生成Hash索引</p><p>这里说一下Hash索引，Hash索引底层是一张Hash表，Hash表是一种key-value存储数据的结构，所以多行数据没有任何顺序关系，所以，对于区间查询，是无法直接通过索引查询的，必须全表扫，Hash索引适合等值查询，但是无法进行范围查询，Hash索引没有办法利用索引完成排序，如果有大量重复键值的情况，Hash索引的效率会很低，因为存在Hash碰撞</p><p>索引采用平衡树的数据结构（非二叉树）也可以叫做B Tree 或 B+ Tree</p><h5 id="聚集索引-（主键索引）"><a href="#聚集索引-（主键索引）" class="headerlink" title="聚集索引 （主键索引）"></a>聚集索引 （主键索引）</h5><p>一个表只能有一个聚集索引，但是聚集索引可能会有多个列</p><p>主键索引的叶子节点存的是整行数据</p><p><img src="/Mysql索引/聚集索引.png" alt></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select * from tableName where id=8</span><br></pre></td></tr></table></figure><p>这个查询会先根据索引定位到id为8的这个叶节点，然后通过叶节点取到id为8的这一行数据</p><p>聚集索引会让查询速度上升，但是会使写入的速度下降，因为增删改都会改变平衡树各节点中的索引内容，破坏树的结构，因此每次数据改变的时候，数据库都会去重新梳理树的结构，以保证结构正确，会有不小的性能开销</p><h5 id="非聚集索引-（其他索引）"><a href="#非聚集索引-（其他索引）" class="headerlink" title="非聚集索引 （其他索引）"></a>非聚集索引 （其他索引）</h5><p><img src="/Mysql索引/非聚集索引.png" alt></p><p>每次给一个字段新建一个索引，字段中的数据就会被复制一份出来，用于生成索引，因此会增加表的体积，占用磁盘空间。</p><p>非聚集索引和聚集索引的区别是，通过聚集索引可以直接查询到数据，而通过    的主键值，然后通过主键值去通过聚集索引查到需要的数据</p><p><img src="/Mysql索引/非聚集索引查询.png" alt></p><h5 id="普通索引和唯一索引"><a href="#普通索引和唯一索引" class="headerlink" title="普通索引和唯一索引"></a>普通索引和唯一索引</h5><p>普通索引和唯一索引查询的过程区别在于，普通索引当查到一条数据之后，会向右继续查询，直到碰到一个不满足的条件，而唯一索引只要查询到匹配的数据之后，不在遍历</p><p>在更新过程的区别在于唯一索引没有change buffer这个操作</p><p><strong>change buffer</strong> 更新操作会先存到change buffer上，然后持久化到磁盘，因为唯一索引在做更新时，会先将数据页读到内存来判断是否唯一，已经读到内存中，直接更新更快，就没必要使用change buffer。</p><p>将数据从磁盘读取到内存设计的随机IO的访问，是数据库里面成本最高的操作之一，change buffer减少了随机磁盘访问，所以对更新性能的提升更明显，因为change buffer在merge的时候才是数据更新的时候，而change buffer是将记录的变更动作缓存下来，所以一个数据页在做merge的时候，change buffer记录的动作越多（更新次数越多），收益越大</p><h4 id="索引优化"><a href="#索引优化" class="headerlink" title="索引优化"></a>索引优化</h4><h5 id="MySQL为什么会选错索引"><a href="#MySQL为什么会选错索引" class="headerlink" title="MySQL为什么会选错索引"></a>MySQL为什么会选错索引</h5><p>在执行SQL的过程中，会经过优化器，数据库会考虑很多条件（回表次数，临时表等），所以会选择错的索引</p><p>这里会考虑一个重要因素就是 show index name   查看索引的技术，索引基数越大，区分度越高，优化器选择该索引的几率越大</p><h5 id="完整索引和前缀索引"><a href="#完整索引和前缀索引" class="headerlink" title="完整索引和前缀索引"></a>完整索引和前缀索引</h5><p>前缀索引适当使用可以节省空间，不怎么增加查询成本</p><p>在一个字符串上建立完整索引，查询过程和非聚集索引查询过程类似</p><p>前缀索引则查询到非聚集索引保存的字段值时会匹配是否和查询条件相等，多了这一步，类似like查询</p><p>前缀索引应该取字符串前几位区分度较大，如区分度不大，则可以采用倒叙存储和hash字段</p><h5 id="覆盖索引"><a href="#覆盖索引" class="headerlink" title="覆盖索引"></a>覆盖索引</h5><p>非聚集索引树上包含了要查询的字段，相当于已经索引已经覆盖了要查询的字段，不需要根据查询到的字段在去主键索引上回表，减少回表次数，这个称谓覆盖索引</p><h5 id="最左前缀原则"><a href="#最左前缀原则" class="headerlink" title="最左前缀原则"></a>最左前缀原则</h5><p>mysql建立多利索引（联合索引）时，有最左前缀原则，即最左优先</p><h5 id="索引下推"><a href="#索引下推" class="headerlink" title="索引下推"></a>索引下推</h5><p>在联合索引内部已经判断了查询中的部分条件，减少回表次数</p><h4 id="MySQL索引优化规则"><a href="#MySQL索引优化规则" class="headerlink" title="MySQL索引优化规则"></a>MySQL索引优化规则</h4><p><strong>1.前导模糊查询不能使用索引。</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select * from doc where title like &apos;%XX&apos;</span><br></pre></td></tr></table></figure><p>而非前导模糊查询则可以使用索引，如下面的 SQL 语句。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select * from doc where title like &apos;XX%&apos;</span><br></pre></td></tr></table></figure><p><strong>2.union、in、or 都能够命中索引，建议使用 in。</strong></p><p><strong>3.负向条件查询不能使用索引，可以优化为 in 查询。</strong></p><p><strong>负向条件有：!=、&lt;&gt;、not in、not exists、not like 等。</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select * from doc where status != 1 and status != 2</span><br></pre></td></tr></table></figure><p>可以优化为 in 查询：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select * from doc where status in (0,3,4)</span><br></pre></td></tr></table></figure><p><strong>4.联合索引最左前缀原则（又叫最左侧查询）</strong></p><p>等号和非等号，应该把等号放在最左侧，并且，把区分列最高的字段放在最左侧查询</p><p><strong>5.把计算放到业务层而不是数据库层。</strong></p><p>在字段上进行计算不能命中索引。</p><p>例如下面的 SQL 语句。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select * from doc where YEAR(create_time) &lt;= &apos;2016&apos;</span><br></pre></td></tr></table></figure><p>即使 date 上建立了索引，也会全表扫描，可优化为值计算，如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select * from doc where create_time &lt;= &apos;2016-01-01&apos;</span><br></pre></td></tr></table></figure><p><strong>6.强制类型转换会全表扫描</strong></p><p> phone 字段是 varchar 类型，则下面的 SQL 不能命中索引。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select * from user where phone=13800001234</span><br></pre></td></tr></table></figure><p>可以优化为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select * from user where phone=&apos;13800001234&apos;</span><br></pre></td></tr></table></figure><p><strong>7.更新十分频繁、数据区分度不高的字段上不宜建立索引。</strong></p><p>更新会改变B+树的结构，更新频繁的话会降低数据库的性能</p><p><strong>8.建立索引的列，不允许为 null。</strong></p><p><strong>9.超过三个表最好不要 join。</strong></p><p><strong>10.如果明确知道只有一条结果返回，limit 1 能够提高效率。</strong></p>]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据库，Mysql </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Dubbo浅谈之SPI</title>
      <link href="/Dubbo%E6%B5%85%E8%B0%88%E4%B9%8BSPI.html"/>
      <url>/Dubbo%E6%B5%85%E8%B0%88%E4%B9%8BSPI.html</url>
      
        <content type="html"><![CDATA[<h4 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h4><p>​    突然发现，自己手动搭建一个项目，从头到尾自己来还是挺锻炼人的，今天尝试了自己在本地使用Dubbo+zookeeper搭建了两个项目，一个作为服务提供端，一个作为消费端，搭建的过程中，问题重重。简直不要太麻烦。</p><p>​    首先在本地启动dubbo-admin就废了好长时间，服务端启动正常，但是消费端没有找到服务，然后又从头来弄服务端，总之，一番周折之后，一个简单的项目能正常跑起来了。在翻阅官方文档的时候，发现了挺有趣的东西，有对源码的分析，写的还挺详细的。</p><p>​    在之前使用WCF的过程中，和这个类似，由于是微软的东西，没有开源，也没有仔细研究怎么实现的，今天就借着官网的文章，来仔细看一下dubbo是怎么一回事</p><h4 id="Dubbo怎么用"><a href="#Dubbo怎么用" class="headerlink" title="Dubbo怎么用"></a>Dubbo怎么用</h4><p>​    这个挺简单的，我个人建议先装dubbo-admin，这样，你才好判断问题在哪，比如是服务没有注册，或者是服务注册成功了，但是消费端出现问题。总之，装了dubbo-admin之后，你才好定位问题在哪。dubbo-admin怎么装就不写了，百度一大堆。</p><p>​    然后就是使用了，先写服务，能注册成功了，在去写消费端，好像是废话。spring boot集成化挺高的，什么东西配置一下就好了，反正不难，出问题百度。啥都有</p><h4 id="SPI"><a href="#SPI" class="headerlink" title="SPI"></a>SPI</h4><p>​    至于dubbo怎么用就不说了，要用上这个东西，挺简单，跟着项目走就好了，无非写方法，调用方法，只不过这个是分布式的，可以跨项目调用，跨项目调用的好处就不言而喻了。中间的实现过程就不需要你管，都有dubbo来做</p><p>​    来说说SPI吧，SPI(<strong>Service Provider Interface</strong>)服务发现机制，<em>SPI 的本质是将接口实现类的全限定名配置在文件中，并由服务加载器读取配置文件，加载实现类。</em>这是官网的话，我可以这么理解，就是将接口的实现类的路径放在一个文件里面，然后需要调用这个方法的时候，我们就去这个文件里面找这个配置的实现类。这样看来，就挺简单的，可配置的东西，理解起来就不难了。</p><h5 id="Java-SPI"><a href="#Java-SPI" class="headerlink" title="Java SPI"></a>Java SPI</h5><p>​    我在我项目里面写了Java SPI的demo源码如下：</p><p>​    首先在resources的下面创建META-INF这个文件夹，然后在下级创建services这个文件夹，为什么叫这个名字，你去看看ServiceLoader的源码就能知道，它是固定使用这个去作为前缀查找配置的实现类</p><p>​    在然后在下面创建一个文件 :这里是重点，需要<strong>创建一个以接口全限定名的配置文件</strong>，具体操作就是找到需要代理的接口，然后右键Copy Reference，就是文件名，文件里面的内容为实现类的全限定名，依旧找到实现类Copy Reference就好了。这是配置，在看看源码吧！</p><p>​    从下面源码能看出来，主要是ServiceLoader.load去加载实现类，然后循环serviceLoader就能将Robot的所有实现方法全部调用</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ServiceLoader&lt;Robot&gt; serviceLoader=ServiceLoader.load(Robot.class);</span><br><span class="line">System.out.println(&quot;java SPI&quot;);</span><br><span class="line">serviceLoader.forEach(Robot::sayHello);</span><br></pre></td></tr></table></figure><p>这里就能看到Java SPI的缺点，它只能通过遍历全部获取，也就是说接口的实现类全部加载实例化了一遍，但是如果接口实现类多了，就很浪费了。换句话说，就是不能通过参数去获取指定的实现类。Dubbo就能。</p><h5 id="Dubbo-SPI"><a href="#Dubbo-SPI" class="headerlink" title="Dubbo SPI"></a>Dubbo SPI</h5><p>依旧说说源码：配置的话，还是在META-INF下面创建一个dubbo文件夹，然后dubbo文件夹里面依旧创建一个和Java SPI一样的全限定名的文件。</p><p>区别来了：在Dubbo SPI里面创建实现类是采用的键值对的形式创建的   <strong>key=com.XXX.XXX</strong> 这个key就是用来我们后续需要获取指定实现类的关键</p><p>下方先获取了接口的所有实现类，然后根据不同的key值，去取不同的实现类，来使用。对的，还需要在接口上面添加@SPI注解，这样ExtensionLoader才能识别到</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ExtensionLoader&lt;Robot&gt; extensionLoader=ExtensionLoader.getExtensionLoader(Robot.class);</span><br><span class="line">Robot optimmusProme=extensionLoader.getExtension(&quot;OptimusProme&quot;);</span><br><span class="line">optimmusProme.sayHello();</span><br><span class="line">Robot bumblebee=extensionLoader.getExtension(&quot;Bumblebee&quot;);</span><br><span class="line">bumblebee.sayHello();</span><br></pre></td></tr></table></figure><p>demo就到这里，这篇文章的重点不是这个，咱们是来看源码的。</p><h5 id="Dubbo-SPI实现源码"><a href="#Dubbo-SPI实现源码" class="headerlink" title="Dubbo SPI实现源码"></a>Dubbo SPI实现源码</h5><p>源码的顺序就从上面的代码来看</p><h6 id="getExtensionLoader"><a href="#getExtensionLoader" class="headerlink" title="getExtensionLoader"></a>getExtensionLoader</h6><p>获取一个ExtensionLoader实例</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">public static &lt;T&gt; ExtensionLoader&lt;T&gt; getExtensionLoader(Class&lt;T&gt; type) &#123;</span><br><span class="line">    if (type == null) &#123;</span><br><span class="line">        throw new IllegalArgumentException(&quot;Extension type == null&quot;);</span><br><span class="line">    &#125; else if (!type.isInterface()) &#123; </span><br><span class="line">        throw new IllegalArgumentException(&quot;Extension type(&quot; + type + &quot;) is not interface!&quot;);</span><br><span class="line">    &#125; else if (!withExtensionAnnotation(type)) &#123; //如果接口上没有@SPI注解，抛异常</span><br><span class="line">        throw new IllegalArgumentException(&quot;Extension type(&quot; + type + &quot;) is not extension, because WITHOUT @&quot; + SPI.class.getSimpleName() + &quot; Annotation!&quot;);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">    //先尝试获取，没有就实例化一个</span><br><span class="line">        ExtensionLoader&lt;T&gt; loader = (ExtensionLoader)EXTENSION_LOADERS.get(type);</span><br><span class="line">        if (loader == null) &#123;</span><br><span class="line">            EXTENSION_LOADERS.putIfAbsent(type, new ExtensionLoader(type));</span><br><span class="line">            loader = (ExtensionLoader)EXTENSION_LOADERS.get(type);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        return loader;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h6 id="getExtension"><a href="#getExtension" class="headerlink" title="getExtension"></a>getExtension</h6><p>获取实现类的对象实例</p><p>看上去和上面的方法挺类似的，先从缓存里面获取实例，没有就new一个，然后从目标对象里面获取方法，如果在没有就去createExtension创建一个</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">public T getExtension(String name) &#123;</span><br><span class="line">    if (name != null &amp;&amp; name.length() != 0) &#123;</span><br><span class="line">        if (&quot;true&quot;.equals(name)) &#123;</span><br><span class="line">        //创建默认的实例</span><br><span class="line">            return this.getDefaultExtension();</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">        //先从缓存获取目标对象</span><br><span class="line">            Holder&lt;Object&gt; holder = (Holder)this.cachedInstances.get(name);</span><br><span class="line">            if (holder == null) &#123;</span><br><span class="line">                this.cachedInstances.putIfAbsent(name, new Holder());</span><br><span class="line">                holder = (Holder)this.cachedInstances.get(name);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            Object instance = holder.get();</span><br><span class="line">            //双重检查</span><br><span class="line">            if (instance == null) &#123;</span><br><span class="line">                synchronized(holder) &#123;</span><br><span class="line">                    instance = holder.get();</span><br><span class="line">                    if (instance == null) &#123;</span><br><span class="line">                    //创建这个实例</span><br><span class="line">                        instance = this.createExtension(name);</span><br><span class="line">                        holder.set(instance);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            return instance;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        throw new IllegalArgumentException(&quot;Extension name == null&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h6 id="createExtension"><a href="#createExtension" class="headerlink" title="createExtension"></a>createExtension</h6><p>创建实例化对象</p><p>我直接在源码里面注释几个重点的地方</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">private T createExtension(String name) &#123;</span><br><span class="line">//获取所有扩展类的实例，然后根据名字获取当前需要获取的实例对象</span><br><span class="line">    Class&lt;?&gt; clazz = (Class)this.getExtensionClasses().get(name);</span><br><span class="line">    if (clazz == null) &#123;</span><br><span class="line">        throw this.findException(name);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            T instance = EXTENSION_INSTANCES.get(clazz);</span><br><span class="line">            if (instance == null) &#123;</span><br><span class="line">            //通过反射获取实例</span><br><span class="line">                EXTENSION_INSTANCES.putIfAbsent(clazz, clazz.newInstance());</span><br><span class="line">                instance = EXTENSION_INSTANCES.get(clazz);</span><br><span class="line">            &#125;</span><br><span class="line">//注入，但是只支持前缀为set的方法实现注入</span><br><span class="line">            this.injectExtension(instance);</span><br><span class="line">            Set&lt;Class&lt;?&gt;&gt; wrapperClasses = this.cachedWrapperClasses;</span><br><span class="line">            Class wrapperClass;</span><br><span class="line">            if (wrapperClasses != null &amp;&amp; !wrapperClasses.isEmpty()) &#123;</span><br><span class="line">                for(Iterator i$ = wrapperClasses.iterator(); i$.hasNext(); instance = this.injectExtension(wrapperClass.getConstructor(this.type).newInstance(instance))) &#123;</span><br><span class="line">                    wrapperClass = (Class)i$.next();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            return instance;</span><br><span class="line">        &#125; catch (Throwable var7) &#123;</span><br><span class="line">            throw new IllegalStateException(&quot;Extension instance(name: &quot; + name + &quot;, class: &quot; + this.type + &quot;)  could not be instantiated: &quot; + var7.getMessage(), var7);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个里面的重点是getExtensionClasses()是获取所有扩展的实例</p><h6 id="getExtensionClasses"><a href="#getExtensionClasses" class="headerlink" title="getExtensionClasses"></a>getExtensionClasses</h6><p>这个获取所有扩展的实例，先从缓存里面获取，没有就去加载扩展的实例</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">private Map&lt;String, Class&lt;?&gt;&gt; getExtensionClasses() &#123;</span><br><span class="line">//从缓存获取</span><br><span class="line">    Map&lt;String, Class&lt;?&gt;&gt; classes = cachedClasses.get();</span><br><span class="line">    //双重检查</span><br><span class="line">    if (classes == null) &#123;</span><br><span class="line">        synchronized (cachedClasses) &#123;</span><br><span class="line">            classes = cachedClasses.get();</span><br><span class="line">            if (classes == null) &#123;</span><br><span class="line">            //加载扩展实例</span><br><span class="line">                classes = loadExtensionClasses();</span><br><span class="line">                cachedClasses.set(classes);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return classes;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h6 id="loadExtensionClasses"><a href="#loadExtensionClasses" class="headerlink" title="loadExtensionClasses"></a>loadExtensionClasses</h6><p>加载所有扩展实例对象，我们只用看下面的loadDirectory就好，上面的是在其他方法调用。</p><p>loadDirectory的第二个参数是三个文件夹，表示，他会从这三个文件夹去找扩展类的实例化方法</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">private Map&lt;String, Class&lt;?&gt;&gt; loadExtensionClasses() &#123;</span><br><span class="line">    final SPI defaultAnnotation = type.getAnnotation(SPI.class);</span><br><span class="line">    if (defaultAnnotation != null) &#123;</span><br><span class="line">        String value = defaultAnnotation.value();</span><br><span class="line">        if ((value = value.trim()).length() &gt; 0) &#123;</span><br><span class="line">            String[] names = NAME_SEPARATOR.split(value);</span><br><span class="line">            if (names.length &gt; 1) &#123;</span><br><span class="line">                throw new IllegalStateException(&quot;more than 1 default extension name on extension &quot; + type.getName()</span><br><span class="line">                        + &quot;: &quot; + Arrays.toString(names));</span><br><span class="line">            &#125;</span><br><span class="line">            if (names.length == 1) cachedDefaultName = names[0];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Map&lt;String, Class&lt;?&gt;&gt; extensionClasses = new HashMap&lt;String, Class&lt;?&gt;&gt;();</span><br><span class="line">    loadDirectory(extensionClasses, DUBBO_INTERNAL_DIRECTORY);</span><br><span class="line">    loadDirectory(extensionClasses, DUBBO_DIRECTORY);</span><br><span class="line">    loadDirectory(extensionClasses, SERVICES_DIRECTORY);</span><br><span class="line">    return extensionClasses;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h6 id="loadDirectory"><a href="#loadDirectory" class="headerlink" title="loadDirectory"></a>loadDirectory</h6><p>从文件夹里面找到接口全限定名的扩展实现</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">private void loadDirectory(Map&lt;String, Class&lt;?&gt;&gt; extensionClasses, String dir) &#123;</span><br><span class="line">    String fileName = dir + type.getName(); //获取文件夹全路径</span><br><span class="line">    try &#123;</span><br><span class="line">        Enumeration&lt;java.net.URL&gt; urls;</span><br><span class="line">        ClassLoader classLoader = findClassLoader();</span><br><span class="line">        if (classLoader != null) &#123;</span><br><span class="line">            urls = classLoader.getResources(fileName);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            urls = ClassLoader.getSystemResources(fileName);</span><br><span class="line">        &#125;</span><br><span class="line">        if (urls != null) &#123;</span><br><span class="line">            while (urls.hasMoreElements()) &#123;</span><br><span class="line">                java.net.URL resourceURL = urls.nextElement();</span><br><span class="line">                //加载实现类</span><br><span class="line">                loadResource(extensionClasses, classLoader, resourceURL);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; catch (Throwable t) &#123;</span><br><span class="line">        logger.error(&quot;Exception when load extension class(interface: &quot; +</span><br><span class="line">                type + &quot;, description file: &quot; + fileName + &quot;).&quot;, t);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h6 id="loadResource"><a href="#loadResource" class="headerlink" title="loadResource"></a>loadResource</h6><p>其实这方法主要是读取文本，解析字符串</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">private void loadResource(Map&lt;String, Class&lt;?&gt;&gt; extensionClasses, ClassLoader classLoader, java.net.URL resourceURL) &#123;</span><br><span class="line">    try &#123;</span><br><span class="line">        BufferedReader reader = new BufferedReader(new InputStreamReader(resourceURL.openStream(), &quot;utf-8&quot;));</span><br><span class="line">        try &#123;</span><br><span class="line">            String line;</span><br><span class="line">            while ((line = reader.readLine()) != null) &#123;</span><br><span class="line">            //不要注释</span><br><span class="line">                final int ci = line.indexOf(&apos;#&apos;);</span><br><span class="line">                if (ci &gt;= 0) line = line.substring(0, ci);</span><br><span class="line">                line = line.trim();</span><br><span class="line">                if (line.length() &gt; 0) &#123;</span><br><span class="line">                    try &#123;</span><br><span class="line">                        String name = null;</span><br><span class="line">                        //按=分割，截取键值对</span><br><span class="line">                        int i = line.indexOf(&apos;=&apos;);</span><br><span class="line">                        if (i &gt; 0) &#123;</span><br><span class="line">                            name = line.substring(0, i).trim();</span><br><span class="line">                            line = line.substring(i + 1).trim();</span><br><span class="line">                        &#125;</span><br><span class="line">                        if (line.length() &gt; 0) &#123;</span><br><span class="line">                        //加载扩展的实例，并且载入缓存</span><br><span class="line">                            loadClass(extensionClasses, resourceURL, Class.forName(line, true, classLoader), name);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125; catch (Throwable t) &#123;</span><br><span class="line">                        IllegalStateException e = new IllegalStateException(&quot;Failed to load extension class(interface: &quot; + type + &quot;, class line: &quot; + line + &quot;) in &quot; + resourceURL + &quot;, cause: &quot; + t.getMessage(), t);</span><br><span class="line">                        exceptions.put(line, e);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; finally &#123;</span><br><span class="line">            reader.close();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; catch (Throwable t) &#123;</span><br><span class="line">        logger.error(&quot;Exception when load extension class(interface: &quot; +</span><br><span class="line">                type + &quot;, class file: &quot; + resourceURL + &quot;) in &quot; + resourceURL, t);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>好了，到这里没什么好讲的了，Dubbo SPI和Java SPI的区别最明显的就是 dubbo SPI是采用键值对的形式，需要哪个实例就去取相应的实例就好了，而Java SPI是遍历使用所有</p><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>有一个全面的文档真好，而且是中文文档，太友好了，不懂的，看看文档，看看代码，调试一下程序，基本就能看个八九不离十，好了，不说了，划水去了。</p>]]></content>
      
      
      <categories>
          
          <category> Dubbo </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Dubbo </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ThreadLocal表层分析</title>
      <link href="/ThreadLocal%E8%A1%A8%E5%B1%82%E5%88%86%E6%9E%90.html"/>
      <url>/ThreadLocal%E8%A1%A8%E5%B1%82%E5%88%86%E6%9E%90.html</url>
      
        <content type="html"><![CDATA[<h4 id="直接开始"><a href="#直接开始" class="headerlink" title="直接开始"></a>直接开始</h4><p>之前在写自定义注解实现多数据源的那篇文章中用过这个ThreadLocal，用这个主要是让每个线程内部有自己独立的数据源信息，就意味着每个线程内部存储着一个单独的数据库连接，这是开始，来看一下是怎么实现的。</p><h4 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h4><p>这个在我看来，看懂了之后很好理解，其实就是在Thread里面维护了一个ThreadLocalMap，然后就做到了线程里面的数据隔离，这个Map用当前线程来做key值，需要存储的对象作为value。大致的意思就是这样了，回过头来说说之前写的自定义注解实现多数据源达到读写分离的目的就是这样，每个方法调用的线程，在执行时，会去判断是使用的哪个数据源，然后切换，保存到ThreadLocalMap里面，保证了当前方法里面都是从指定的数据源操作数据</p><h4 id="源码"><a href="#源码" class="headerlink" title="源码"></a>源码</h4><p>不多说了，也没什么说的，直接看源码吧，挺简单的，主要是两个方法 <strong>get()</strong> ，<strong>set()</strong>。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Returns the value in the current thread&apos;s copy of this</span><br><span class="line"> * thread-local variable.  If the variable has no value for the</span><br><span class="line"> * current thread, it is first initialized to the value returned</span><br><span class="line"> * by an invocation of the &#123;@link #initialValue&#125; method.</span><br><span class="line"> *</span><br><span class="line"> * @return the current thread&apos;s value of this thread-local</span><br><span class="line"> */</span><br><span class="line">public T get() &#123;</span><br><span class="line">//获取到当前线程</span><br><span class="line">    Thread t = Thread.currentThread();</span><br><span class="line">    //获取当前线程的ThreadLocalMap</span><br><span class="line">    ThreadLocalMap map = getMap(t);</span><br><span class="line">    if (map != null) &#123;</span><br><span class="line">    //取到以当前线程为key的值</span><br><span class="line">        ThreadLocalMap.Entry e = map.getEntry(this);</span><br><span class="line">        if (e != null) &#123;</span><br><span class="line">        //转换格式直接返回</span><br><span class="line">            @SuppressWarnings(&quot;unchecked&quot;)</span><br><span class="line">            T result = (T)e.value;</span><br><span class="line">            return result;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    //如果没有map或者值为null,则初始化一个值为null,返回</span><br><span class="line">    return setInitialValue();</span><br><span class="line">&#125;</span><br><span class="line">    /**</span><br><span class="line"> * Variant of set() to establish initialValue. Used instead</span><br><span class="line"> * of set() in case user has overridden the set() method.</span><br><span class="line"> * 设置初始值 为null</span><br><span class="line"> * @return the initial value</span><br><span class="line"> */</span><br><span class="line"> </span><br><span class="line">private T setInitialValue() &#123;</span><br><span class="line">    T value = initialValue();</span><br><span class="line">    Thread t = Thread.currentThread();</span><br><span class="line">    ThreadLocalMap map = getMap(t);</span><br><span class="line">    if (map != null)</span><br><span class="line">        map.set(this, value);</span><br><span class="line">    else</span><br><span class="line">        createMap(t, value);</span><br><span class="line">    return value;</span><br><span class="line">&#125;</span><br><span class="line">protected T initialValue() &#123;</span><br><span class="line">    return null;</span><br><span class="line">&#125;</span><br><span class="line">/**</span><br><span class="line"> * Sets the current thread&apos;s copy of this thread-local variable</span><br><span class="line"> * to the specified value.  Most subclasses will have no need to</span><br><span class="line"> * override this method, relying solely on the &#123;@link #initialValue&#125;</span><br><span class="line"> * method to set the values of thread-locals.</span><br><span class="line"> *</span><br><span class="line"> * @param value the value to be stored in the current thread&apos;s copy of</span><br><span class="line"> *        this thread-local.</span><br><span class="line"> */</span><br><span class="line">public void set(T value) &#123;</span><br><span class="line">//获取当前线程</span><br><span class="line">    Thread t = Thread.currentThread();</span><br><span class="line">    //依旧是getmMap</span><br><span class="line">    ThreadLocalMap map = getMap(t);</span><br><span class="line">    if (map != null)</span><br><span class="line">    //设置值</span><br><span class="line">        map.set(this, value);</span><br><span class="line">    else</span><br><span class="line">    //没有这个Map就创建这个map</span><br><span class="line">        createMap(t, value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>get和set到这就没了，这两个方法挺简单的，但是ThreadLocalMap里面是维护的一个Entry数组，这个数组使用的是弱引用，弱引用在深入理解Java虚拟机的时候讲了一下，这里用上了，就在看看</p><h5 id="弱引用："><a href="#弱引用：" class="headerlink" title="弱引用："></a>弱引用：</h5><p>WeakReference 在每次执行GC的时候就会将这块清除掉，不用管内存是否足够，但是这里有个问题，就是只在key上面用了弱引用，但是此时value值还没有被垃圾回收，所以要完全回收这块的数据，只靠弱引用是没办法完全清除的，必须要调用一下ThreadLocal的remove方法，他会将value的值设置为null,等待GC </p>]]></content>
      
      
      <categories>
          
          <category> JAVA </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 源码，JAVA，线程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>线程同步组件CountDownLatch与CyclicBarrier</title>
      <link href="/%E7%BA%BF%E7%A8%8B%E5%90%8C%E6%AD%A5%E7%BB%84%E4%BB%B6CountDownLatch%E4%B8%8ECyclicBarrier.html"/>
      <url>/%E7%BA%BF%E7%A8%8B%E5%90%8C%E6%AD%A5%E7%BB%84%E4%BB%B6CountDownLatch%E4%B8%8ECyclicBarrier.html</url>
      
        <content type="html"><![CDATA[<h4 id="前文"><a href="#前文" class="headerlink" title="前文"></a>前文</h4><p>闲来无事，随便看看，看到了两个同步组件，正想前段时间看了ReentrantLock之后了解了一下AQS就没怎么看关于并发这块的源码了，今天下午没事，来看看，做个记录</p><h4 id="开始"><a href="#开始" class="headerlink" title="开始"></a>开始</h4><p>感觉自己看源码越来越快了，因为知道源码里面一些常用的套路，知道他是做什么的，只用看看大致的流程，就能明白他要做什么，挺厉害的，加油哦。</p><h4 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h4><p>CountDownLatch是JUC包里面类似于计数器的组件，一般用来等待其他线程执行完毕之后，在去执行其他操作，或者执行主线程</p><h4 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h4><h5 id="CountDownLatch"><a href="#CountDownLatch" class="headerlink" title="CountDownLatch"></a>CountDownLatch</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String[] args)throws InterruptedException &#123;</span><br><span class="line"></span><br><span class="line">    CountDownLatch countDownLatch = new CountDownLatch(6);</span><br><span class="line">    ExecutorService executorService = Executors.newFixedThreadPool(6);</span><br><span class="line">    for (int i = 0; i &lt; 6; i++) &#123;</span><br><span class="line">        executorService.execute(() -&gt; &#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + &quot; 开始等待！！！&quot;);</span><br><span class="line">            countDownLatch.countDown();</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    countDownLatch.await();</span><br><span class="line">    System.out.println(&quot;起飞咯！！！&quot;);</span><br><span class="line">    executorService.shutdown();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">pool-1-thread-1 开始等待！！！</span><br><span class="line">pool-1-thread-3 开始等待！！！</span><br><span class="line">pool-1-thread-2 开始等待！！！</span><br><span class="line">pool-1-thread-4 开始等待！！！</span><br><span class="line">pool-1-thread-5 开始等待！！！</span><br><span class="line">pool-1-thread-6 开始等待！！！</span><br><span class="line">起飞咯！！！</span><br></pre></td></tr></table></figure><p>这个例子是很正常的例子，保证线程数和CountDownLatch的数是一致，他会等待等同于计数器数量的线程准备好之后，在去执行其他线程，这里的其他线程是主线程，这个效果不明显，我现在将CountDownLatch初始化的参数改为7</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CountDownLatch countDownLatch = new CountDownLatch(7);</span><br></pre></td></tr></table></figure><p>这表示会等待7个线程然后在执行主线程，但是在for循环里面我们只初始化了6条线程，所以主线程会一直等待，因为我们没有设置超时时间并且线程数没有达到计数器里面的7个</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">pool-1-thread-1 开始等待！！！</span><br><span class="line">pool-1-thread-2 开始等待！！！</span><br><span class="line">pool-1-thread-3 开始等待！！！</span><br><span class="line">pool-1-thread-4 开始等待！！！</span><br><span class="line">pool-1-thread-5 开始等待！！！</span><br><span class="line">pool-1-thread-6 开始等待！！！</span><br></pre></td></tr></table></figure><p>在举一个例子，我们将7改成1</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CountDownLatch countDownLatch = new CountDownLatch(1);</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">pool-1-thread-2 开始等待！！！</span><br><span class="line">pool-1-thread-1 开始等待！！！</span><br><span class="line">起飞咯！！！</span><br><span class="line">pool-1-thread-3 开始等待！！！</span><br><span class="line">pool-1-thread-4 开始等待！！！</span><br><span class="line">pool-1-thread-6 开始等待！！！</span><br><span class="line">pool-1-thread-5 开始等待！！！</span><br></pre></td></tr></table></figure><p>此时计数器只用执行一遍countDown()就会唤醒其他所有线程包括主线程，所以例子里面的起飞咯在线程还没有等待完毕就已经执行完了</p><h5 id="CyclicBarrier"><a href="#CyclicBarrier" class="headerlink" title="CyclicBarrier"></a>CyclicBarrier</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">private CyclicBarrier cyclicBarrier;</span><br><span class="line">public CyclicBarrierDemo(CyclicBarrier cyclicBarrier)&#123;</span><br><span class="line">    this.cyclicBarrier=cyclicBarrier;</span><br><span class="line">&#125;</span><br><span class="line">@Override</span><br><span class="line">public void run() &#123;</span><br><span class="line">    System.out.println(&quot;线程&quot;+Thread.currentThread().getName()+&quot;准备！&quot;);</span><br><span class="line">    try &#123;</span><br><span class="line">        cyclicBarrier.await();</span><br><span class="line">        System.out.println(&quot;线程&quot;+Thread.currentThread().getName()+&quot;结束！&quot;);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125; catch (InterruptedException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125; catch (BrokenBarrierException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">    CyclicBarrier cyclicBarrier=new CyclicBarrier(11);</span><br><span class="line">    Executor executor=Executors.newFixedThreadPool(10);</span><br><span class="line">    for(int i=0;i&lt;10;i++)&#123;</span><br><span class="line">        executor.execute(new CyclicBarrierDemo(cyclicBarrier));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个结果和CountDownLatch差不多，也是等待一个时机，然后一起执行后续操作，但是还有一些细微差别，在后面在来分析</p><h4 id="源码"><a href="#源码" class="headerlink" title="源码"></a>源码</h4><h5 id="CountDownLatch-1"><a href="#CountDownLatch-1" class="headerlink" title="CountDownLatch"></a>CountDownLatch</h5><p>源码挺简单的，前面分析过ReentrantLock和部分AQS的源码，在来看这个就很容易</p><p>这个源码我主要说三个方法，也是两个比较核心的方法</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">public void countDown() //计数器-1</span><br><span class="line">public void await() //线程等待</span><br></pre></td></tr></table></figure><p>这个唯一的构造函数必须执行一个参数，就是计数器的数值，里面也是使用的Sync同步组件</p><p>在构造函数里面new了Sync类，将计数器的值传入，然后设置state的值为count,看到这里应该就明白一大半了，之前ReentrantLock里面的可重入锁也是这样，如果相同线程进入了同一个锁，会将state的值不断的+1 然后解锁就是不断的-1</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Constructs a &#123;@code CountDownLatch&#125; initialized with the given count.</span><br><span class="line"> *</span><br><span class="line"> * @param count the number of times &#123;@link #countDown&#125; must be invoked</span><br><span class="line"> *        before threads can pass through &#123;@link #await&#125;</span><br><span class="line"> * @throws IllegalArgumentException if &#123;@code count&#125; is negative</span><br><span class="line"> */</span><br><span class="line">public CountDownLatch(int count) &#123;</span><br><span class="line">    if (count &lt; 0) throw new IllegalArgumentException(&quot;count &lt; 0&quot;);</span><br><span class="line">    //new Sync</span><br><span class="line">    this.sync = new Sync(count);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Sync(int count) &#123;</span><br><span class="line">   setState(count);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h6 id="countDown"><a href="#countDown" class="headerlink" title="countDown()"></a>countDown()</h6><p>先来看看countDown方法，这个方法是将计数器的值-1</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">public void countDown() &#123;</span><br><span class="line">    sync.releaseShared(1);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//尝试将计数器的值+1 如果达到了初始化设置的count值，就激活所有线程</span><br><span class="line">public final boolean releaseShared(int arg) &#123;</span><br><span class="line">    if (tryReleaseShared(arg)) &#123;</span><br><span class="line">    //如果tryReleaseShared返回true,表示达到了count的值，就会激活所有线程</span><br><span class="line">    //上述例子中将count的值设置小于线程数，所以激活所有线程包括主线程，主线程就执行了</span><br><span class="line">        doReleaseShared();</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line">    return false;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h6 id="await"><a href="#await" class="headerlink" title="await()"></a>await()</h6><p>这个方法是将当前线程等待，如果计数器未达到设定值，将一直等待，上述例子也有，当计数器设置为7时，只new  6条线程，所以主线程会一直等待</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><span class="line">  public void await() throws InterruptedException &#123;</span><br><span class="line">      sync.acquireSharedInterruptibly(1);</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">   public final void acquireSharedInterruptibly(int arg)</span><br><span class="line">          throws InterruptedException &#123;</span><br><span class="line">      //判断线程是否中断</span><br><span class="line">      if (Thread.interrupted())</span><br><span class="line">          throw new InterruptedException();</span><br><span class="line">      //判断计数器也就是当前锁的状态，如果state不为0,则需要将线程挂起</span><br><span class="line">      if (tryAcquireShared(arg) &lt; 0)</span><br><span class="line">      //挂起线程</span><br><span class="line">          doAcquireSharedInterruptibly(arg);</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  //判断计数器的值</span><br><span class="line">  protected int tryAcquireShared(int acquires) &#123;</span><br><span class="line">          return (getState() == 0) ? 1 : -1;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line">  private void doAcquireSharedInterruptibly(int arg)</span><br><span class="line">      throws InterruptedException &#123;</span><br><span class="line">      //先往AQS里面添加一个节点，这个addWaiter在ReentrantLock里面有分析</span><br><span class="line">      //会往AQS的尾部添加一个节点</span><br><span class="line">      final Node node = addWaiter(Node.SHARED);</span><br><span class="line">      boolean failed = true;</span><br><span class="line">      try &#123;</span><br><span class="line">          for (;;) &#123;//自旋</span><br><span class="line">          //得到前节点</span><br><span class="line">              final Node p = node.predecessor();</span><br><span class="line">              //如果前节点是头节点，则开始尝试激活</span><br><span class="line">              if (p == head) &#123;</span><br><span class="line">              //尝试获取当前状态，如果为0返回1 如果不为0 返回 -1</span><br><span class="line">                  int r = tryAcquireShared(arg);</span><br><span class="line">                  if (r &gt;= 0) &#123;//表示当前状态为0，可以激活线程</span><br><span class="line">                  //</span><br><span class="line">                      setHeadAndPropagate(node, r);</span><br><span class="line">                      p.next = null; // help GC</span><br><span class="line">                      failed = false;</span><br><span class="line">                      return;</span><br><span class="line">                  &#125;</span><br><span class="line">              &#125;</span><br><span class="line">              //这个之前看过</span><br><span class="line">              //判断线程是否应该阻塞，如果是，则安全阻塞，进入到parkAndCheckInterrupt将线程挂起</span><br><span class="line">              if (shouldParkAfterFailedAcquire(p, node) &amp;&amp;</span><br><span class="line">                  parkAndCheckInterrupt())</span><br><span class="line">                  throw new InterruptedException();</span><br><span class="line">          &#125;</span><br><span class="line">      &#125; finally &#123;</span><br><span class="line">          if (failed) </span><br><span class="line">          // 如果出现异常，则取消锁的获取，进行出队操作</span><br><span class="line">              cancelAcquire(node);</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  //设置成头节点，并通过propagate判断是否可以激活</span><br><span class="line">private void setHeadAndPropagate(Node node, int propagate) &#123;</span><br><span class="line">      Node h = head; // Record old head for check below</span><br><span class="line">      setHead(node); //设置头结点</span><br><span class="line">      /*</span><br><span class="line">       * Try to signal next queued node if:</span><br><span class="line">       *   Propagation was indicated by caller,</span><br><span class="line">       *     or was recorded (as h.waitStatus either before</span><br><span class="line">       *     or after setHead) by a previous operation</span><br><span class="line">       *     (note: this uses sign-check of waitStatus because</span><br><span class="line">       *      PROPAGATE status may transition to SIGNAL.)</span><br><span class="line">       * and</span><br><span class="line">       *   The next node is waiting in shared mode,</span><br><span class="line">       *     or we don&apos;t know, because it appears null</span><br><span class="line">       *</span><br><span class="line">       * The conservatism in both of these checks may cause</span><br><span class="line">       * unnecessary wake-ups, but only when there are multiple</span><br><span class="line">       * racing acquires/releases, so most need signals now or soon</span><br><span class="line">       * anyway.</span><br><span class="line">       */</span><br><span class="line">      </span><br><span class="line">      if (propagate &gt; 0 || h == null || h.waitStatus &lt; 0 ||</span><br><span class="line">          (h = head) == null || h.waitStatus &lt; 0) &#123;</span><br><span class="line">          Node s = node.next;</span><br><span class="line">          //判断是否共享模式</span><br><span class="line">          if (s == null || s.isShared())</span><br><span class="line">          //进行共享模式的释放</span><br><span class="line">              doReleaseShared();</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>这个CountDownLatch看了，其实看源码很好理解，但是又深入到AQS里面去了，也有很多地方不懂，刚刚在查资料的过程中，看到了几个新名字，也不算新名字吧，只是对概念的模糊不清在这记录一下</p><h5 id="题外"><a href="#题外" class="headerlink" title="题外"></a>题外</h5><p><strong>AQS</strong>是AbstractQueuedSynchronizer的简称，AQS提供了一种实现阻塞锁和一系列依赖FIFO等待队列的同步器的框架</p><p><strong>CLH</strong>是一个自旋锁，能确保无饥饿性，提供先来先服务的公平性。CLH锁也是一种基于链表的可扩展、高性能、公平的自旋锁，申请线程只在本地变量上自旋，它不断轮询前驱的状态，如果发现前驱释放了锁就结束自旋。</p><p>AQS中有两种获取和释放资源的模式。</p><p>AQS独占模式**只允许同时一个线程获取同一个许可。可以对应为一些锁ReetrantLock</p><p><strong>AQS共享模式</strong>允许同时多个线程获取同一个许可。可以对应一些同步器类似CountDownLatch，CyclicBarrier</p><h5 id="CyclicBarrier-1"><a href="#CyclicBarrier-1" class="headerlink" title="CyclicBarrier"></a>CyclicBarrier</h5><h6 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">//parties可以理解为一个屏障</span><br><span class="line">public CyclicBarrier(int parties) &#123;</span><br><span class="line">    this(parties, null);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//构造函数会调用这个，其实parties，count和CountDownLatch类似</span><br><span class="line">public CyclicBarrier(int parties, Runnable barrierAction) &#123;</span><br><span class="line">    if (parties &lt;= 0) throw new IllegalArgumentException();</span><br><span class="line">    this.parties = parties;</span><br><span class="line">    this.count = parties;</span><br><span class="line">    this.barrierCommand = barrierAction;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h6 id="await-1"><a href="#await-1" class="headerlink" title="await()"></a>await()</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><span class="line"> public int await() throws InterruptedException, BrokenBarrierException &#123;</span><br><span class="line">     try &#123;</span><br><span class="line">         return dowait(false, 0L);</span><br><span class="line">     &#125; catch (TimeoutException toe) &#123;</span><br><span class="line">         throw new Error(toe); // cannot happen</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br><span class="line"> //核心方法就是这个，他不需要像CountDownLatch一样，需要调用CountDown</span><br><span class="line"> //而是直接去--count，然后</span><br><span class="line"> private int dowait(boolean timed, long nanos)</span><br><span class="line">     throws InterruptedException, BrokenBarrierException,</span><br><span class="line">            TimeoutException &#123;</span><br><span class="line">     final ReentrantLock lock = this.lock;</span><br><span class="line">     lock.lock();</span><br><span class="line">     try &#123;</span><br><span class="line">         final Generation g = generation;</span><br><span class="line"></span><br><span class="line">         if (g.broken)</span><br><span class="line">             throw new BrokenBarrierException();</span><br><span class="line"></span><br><span class="line">         if (Thread.interrupted()) &#123;</span><br><span class="line">             breakBarrier();</span><br><span class="line">             throw new InterruptedException();</span><br><span class="line">         &#125;</span><br><span class="line">//将count减1  </span><br><span class="line">         int index = --count;</span><br><span class="line">         //如果等于0，则表示已经达到屏障，就可以开始执行唤醒操作</span><br><span class="line">         if (index == 0) &#123;  // tripped</span><br><span class="line">             boolean ranAction = false;</span><br><span class="line">             try &#123;</span><br><span class="line">                 final Runnable command = barrierCommand;</span><br><span class="line">                 if (command != null)</span><br><span class="line">                     command.run();</span><br><span class="line">                 ranAction = true;</span><br><span class="line">                 nextGeneration();</span><br><span class="line">                 return 0;</span><br><span class="line">             &#125; finally &#123;</span><br><span class="line">                 if (!ranAction)</span><br><span class="line">                     breakBarrier();</span><br><span class="line">             &#125;</span><br><span class="line">         &#125;</span><br><span class="line"></span><br><span class="line">         // loop until tripped, broken, interrupted, or timed out</span><br><span class="line">         //线程运行到这里，就会被屏障挡住，执行await方法，挂起线程</span><br><span class="line">         for (;;) &#123;</span><br><span class="line">             try &#123;</span><br><span class="line">             //这里是设置超时操作的一些，这次先不管</span><br><span class="line">                 if (!timed)</span><br><span class="line">                     trip.await();</span><br><span class="line">                 else if (nanos &gt; 0L)</span><br><span class="line">                     nanos = trip.awaitNanos(nanos);</span><br><span class="line">             &#125; catch (InterruptedException ie) &#123;</span><br><span class="line">            //如果抛出异常，则破坏屏障，然后抛出异常</span><br><span class="line">                 if (g == generation &amp;&amp; ! g.broken) &#123;</span><br><span class="line">                     breakBarrier();</span><br><span class="line">                     throw ie;</span><br><span class="line">                 &#125; else &#123;</span><br><span class="line">                     // We&apos;re about to finish waiting even if we had not</span><br><span class="line">                     // been interrupted, so this interrupt is deemed to</span><br><span class="line">                     // &quot;belong&quot; to subsequent execution.</span><br><span class="line">                     Thread.currentThread().interrupt();</span><br><span class="line">                 &#125;</span><br><span class="line">             &#125;</span><br><span class="line"></span><br><span class="line">             if (g.broken)</span><br><span class="line">                 throw new BrokenBarrierException();</span><br><span class="line"></span><br><span class="line">//如果换了新的一轮，返回上一轮线程达到count的顺序</span><br><span class="line">             if (g != generation)</span><br><span class="line">                 return index;</span><br><span class="line"></span><br><span class="line">             if (timed &amp;&amp; nanos &lt;= 0L) &#123;</span><br><span class="line">                 breakBarrier();</span><br><span class="line">                 throw new TimeoutException();</span><br><span class="line">             &#125;</span><br><span class="line">         &#125;</span><br><span class="line">     &#125; finally &#123;</span><br><span class="line">         lock.unlock();</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br><span class="line"> </span><br><span class="line"> //唤醒，然后重新激活，重置count值和屏障</span><br><span class="line"> private void breakBarrier() &#123;</span><br><span class="line">     generation.broken = true;</span><br><span class="line">     count = parties;</span><br><span class="line">     trip.signalAll();</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>这个就简单多了，这两个同步计数器，其实实现的功能差不多，下面再来看看一些细微的区别</p><h4 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h4><p>CountDownLatch是执行的CountDown()方法将计数器的值-1，这个是可控的，如果数值减到0之后，就开始执行后续操作</p><p>CyclicBarrier 是只用让方法await()等待之后，内部会自动去-1，然后达到初始化设置的值，就会激活全部线程</p><p>如果难理解的话，我举个例子</p><p>CountDownLatch就好比一个跑步比赛，来了一个人，计数器就 -1 ，人来起了，计数器到0了，则就开始跑，此时await阻塞的是主体，都不能动</p><p>CyclicBarrier 更像是一个屏障，屏障只能承受10g的力量，来了一个线程就相当于给这个屏障加了1g,然后达到10g的时候，这个屏障就会破了，然后所有线程一起跑起来，然后跑完了，自动修复，等着承受下一个10g,这个await阻塞的是单个线程</p><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>快下班了，今天星期五，收货颇丰，研究了两个同步计数器，感觉AQS里面的内容，我看的还是太片面了，没有顾上整体，在今天查资料的过程中，看到了很多东西理解起来还是有点困难，接下来研究到了在继续分析</p><h4 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h4><p>​    这段时间看的东西比较杂，这里看一下，那里看一下，看到什么东西，就研究一下，不知道好不好，反正我感觉挺乱的，项目这段时间也不是挺忙，上述的两个计数器在项目里面搜了一下，基本上没怎么用，只能说以后要用了，知道这个东西，能快速的上手。</p><p>​    最近感觉来自于经济方面的压力越来越大，房贷已经还了3个月，基本上就是还了房贷，就没啥钱的地步了，可能近几年是最难熬的几年吧，以后转了公积金，或者一个收入水平提升就会好一点，突然想到我还蛮像乐观锁的，先啥也不管，该吃吃该喝喝，等出问题，在来想办法，哈哈。加油哦，给自己一个目标吧，明年尝试去面试，去看看外面的世界是什么样的，说不定能对自己目前的收入水平得到一个提升</p>]]></content>
      
      
      <categories>
          
          <category> 并发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 并发，JAVA，源码 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>排序算法：基数排序</title>
      <link href="/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%EF%BC%9A%E5%9F%BA%E6%95%B0%E6%8E%92%E5%BA%8F.html"/>
      <url>/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%EF%BC%9A%E5%9F%BA%E6%95%B0%E6%8E%92%E5%BA%8F.html</url>
      
        <content type="html"><![CDATA[<h4 id="前文"><a href="#前文" class="headerlink" title="前文"></a>前文</h4><p>依旧闲来无事，随便划一下水，看到一个基数排序，挺有意思，在这做个记录</p><h4 id="开始"><a href="#开始" class="headerlink" title="开始"></a>开始</h4><p>之前也看断断续续写了很多代码，玩了很多有趣的东西，但是都没有留下任何记录，包括但 不限于用pyhton写的爬虫，爬的妹子图，爬的疾病分类，以及借助于第三方的插件，实现简单的微信群发功能，当然也有一些类似的排序，还有一些新技术的探索，平常写了也就写了，代码是不值钱的，基本上写了就不管了，所以也有很多代码遗失，想想还挺可惜，所以现在写了啥，都要做个记录，养成习惯。</p><h4 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h4><p>开局一张图，过程全靠编，看一张图吧，挺好理解的！</p><p><img src="/排序算法：基数排序/radixSort.gif" alt></p><p>这张图什么意思呢？</p><p>就是下面的0-9就相当于桶，然后按照数字的个位十位百位来依次放入对应的桶中，然后循环最大的数的长度，然后反复来几次，就排序成功，挺简单</p><h5 id="是什么？"><a href="#是什么？" class="headerlink" title="是什么？"></a>是什么？</h5><blockquote><p>基数排序（radix sort）属于“分配式排序”（distribution sort），又称“桶子法”（bucket sort）或bin sort，顾名思义，它是透过键值的部份资讯，将要排序的<a href="https://baike.baidu.com/item/元素分配/2107419" target="_blank" rel="noopener">元素分配</a>至某些“桶”中，藉以达到排序的作用，基数排序法是属于稳定性的排序，其<a href="https://baike.baidu.com/item/时间复杂度/1894057" target="_blank" rel="noopener">时间复杂度</a>为O (nlog(r)m)，其中r为所采取的基数，而m为堆数，在某些时候，基数排序法的效率高于其它的稳定性排序法。 </p></blockquote><p>上述一段话，来源于百度百科，其实很好理解，看图就知道了，0-9可以理解为桶，然后将每个数的单独位数的值循环计数排序，最后一次排序成功</p><p>基数排序有两种方法：1、<strong>LSD 最低位优先</strong>即从数字的右边开始 。2、<strong>MSD 最高位优先</strong>从最左边开始</p><h5 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line">/***</span><br><span class="line"> * 基数排序</span><br><span class="line"> */</span><br><span class="line">public static void radixSort()&#123;</span><br><span class="line">    int[] array = &#123;12, 33, 1, 4,543, 2, 444, 12&#125;;</span><br><span class="line">    int max = array[0];</span><br><span class="line"></span><br><span class="line">    //找到数组中的最大值  需要判断最大的数是多少位</span><br><span class="line">    for(int i=0;i&lt;array.length;i++)&#123;</span><br><span class="line">        if(array[i]&gt;max)&#123;</span><br><span class="line">            max = array[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //取到最大数的长度，用maxLen存着</span><br><span class="line">    int maxLen = 0;</span><br><span class="line">    while(max&gt;0)&#123;</span><br><span class="line">        max /= 10;</span><br><span class="line">        maxLen++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //buckets 为桶  外面的list存放 0-9个桶，每个桶里面装当前排序的数字</span><br><span class="line">    List&lt;List&lt;Integer&gt;&gt; buckets = new ArrayList&lt;&gt;();</span><br><span class="line">    //0-9十个数  new 十个桶</span><br><span class="line">    for(int i=0;i&lt;10;i++)&#123;</span><br><span class="line">        //桶由ArrayList&lt;Integer&gt;构成</span><br><span class="line">        buckets.add(new ArrayList&lt;&gt;());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //按照数组里面最大的数的长度去循环，个，十，百，千，万。。。。等单独位数</span><br><span class="line">    for(int i=0;i&lt;maxLen;i++)&#123;</span><br><span class="line">        //扫描所有数组元素，将元素按照每一位的大小分配到对应的桶中</span><br><span class="line">        for(int j=0;j&lt;array.length;j++)&#123;</span><br><span class="line">            //取出一个数字上的第 i+1 位</span><br><span class="line">            //取余  12%10=2  234%100=34   次方  Math.pow(a,b)  a的b次方</span><br><span class="line">            // 例：取个位  543%10=3  3/0=3    取十位  543%100=43   43/10=4</span><br><span class="line">            int key =array[j]%(int)Math.pow(10, i+1)/(int)Math.pow(10, i);</span><br><span class="line"></span><br><span class="line">            //将取出来的数字先获取到该桶的位置，然后将数组中对应的值放到该桶中</span><br><span class="line">            buckets.get(key).add(array[j]);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        //分配完之后 将桶中的数据拿出来，放到数组中排序</span><br><span class="line">        //数组索引</span><br><span class="line">        int counter = 0;</span><br><span class="line">        for(int j=0;j&lt;10;j++)&#123;</span><br><span class="line">            //遍历0-9的桶</span><br><span class="line">            List&lt;Integer&gt; bucket =buckets.get(j);</span><br><span class="line">            //将桶里面的数据拿出来 遍历到数组里面</span><br><span class="line">            while(bucket.size()&gt;0)&#123;</span><br><span class="line">                //将桶中的第一个元素复制到数组，并移除</span><br><span class="line">                array[counter++] = bucket.remove(0);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.print(&quot;第&quot;+(i+1)+&quot;轮排序：&quot;);</span><br><span class="line">        for(int o : array)&#123;</span><br><span class="line">            System.out.print(o+&quot; &quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>先按照循环来说</p><p>1、第一个循环就是将数组里面最大的值找出来</p><p>2、第二个循环是按照最大的数字计算出数字的长度有多少位</p><p>3、使用List初始化桶</p><p>4、外面的循环是需要按照最大的数的长度来遍历</p><p>​    1、这个循环最重要，取出每个数位上面的数字来放入对应的桶中</p><p>​            上面代码中的注释有取出的方法</p><p>​    2、这个循环是取出每个桶中对应的值，然后将这些值放到原数组中</p><p>上述就是这个代码，主要看图</p><h5 id="引申"><a href="#引申" class="headerlink" title="引申"></a>引申</h5><p>这个不能排负数，和字母，如果需要排字母，可以获取到字母的ASCII码，在排序ASCII码就好了，因为字母的顺序和它ASCII码的顺序是一一对应的</p>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法，JAVA，排序 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>为什么For循环操作List会报错</title>
      <link href="/%E4%B8%BA%E4%BB%80%E4%B9%88For%E5%BE%AA%E7%8E%AF%E6%93%8D%E4%BD%9CList%E4%BC%9A%E6%8A%A5%E9%94%99.html"/>
      <url>/%E4%B8%BA%E4%BB%80%E4%B9%88For%E5%BE%AA%E7%8E%AF%E6%93%8D%E4%BD%9CList%E4%BC%9A%E6%8A%A5%E9%94%99.html</url>
      
        <content type="html"><![CDATA[<h4 id="为什么For循环操作List会报错？"><a href="#为什么For循环操作List会报错？" class="headerlink" title="为什么For循环操作List会报错？"></a>为什么For循环操作List会报错？</h4><h5 id="分析问题"><a href="#分析问题" class="headerlink" title="分析问题"></a>分析问题</h5><p>这是今天下午突然想到的一个问题，闲来无事，探探究竟！</p><p>先来看看Demo</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String[] args) &#123;</span><br><span class="line"></span><br><span class="line">        List&lt;String&gt; list = new ArrayList();</span><br><span class="line">        list.add(&quot;java01&quot;);</span><br><span class="line">        list.add(&quot;java02&quot;);</span><br><span class="line">        list.add(&quot;java03&quot;);</span><br><span class="line"></span><br><span class="line">        //正常</span><br><span class="line">        Iterator iterator=list.iterator();</span><br><span class="line">        while(iterator.hasNext())&#123;</span><br><span class="line">            if(&quot;java01&quot;.equals(iterator.next()))&#123;</span><br><span class="line">                iterator.remove();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        //异常 java.util.ConcurrentModificationException</span><br><span class="line">        for (String str:list)&#123;</span><br><span class="line">            if(&quot;java01&quot;.equals(str))&#123;</span><br><span class="line">                list.remove(1);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        //异常 java.util.ConcurrentModificationException</span><br><span class="line">        for (String str:list)&#123;</span><br><span class="line">            if(&quot;java01&quot;.equals(str))&#123;</span><br><span class="line">                list.add(&quot;java04&quot;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>在使用Iterator去遍历这个List的时候就不会报错，使用For循环去直接操作List就会抛出<strong>java.util.ConcurrentModificationException</strong>这个错误。先来看看为什么会有这个错误。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Exception in thread &quot;main&quot; java.util.ConcurrentModificationException</span><br><span class="line">at java.util.ArrayList$Itr.checkForComodification(ArrayList.java:909)</span><br><span class="line">at java.util.ArrayList$Itr.next(ArrayList.java:859)</span><br><span class="line">at com.mybatis.example.main.main(main.java:38)</span><br></pre></td></tr></table></figure><p>这个是异常，可以看到在ArrayList的909行抛出异常了</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">final void checkForComodification() &#123;</span><br><span class="line">           if (modCount != expectedModCount)</span><br><span class="line">               throw new ConcurrentModificationException();</span><br><span class="line">&#125;</span><br><span class="line">public E next() &#123;</span><br><span class="line">           checkForComodification();</span><br><span class="line">           int i = cursor;</span><br><span class="line">           if (i &gt;= size)</span><br><span class="line">               throw new NoSuchElementException();</span><br><span class="line">           Object[] elementData = ArrayList.this.elementData;</span><br><span class="line">           if (i &gt;= elementData.length)</span><br><span class="line">               throw new ConcurrentModificationException();</span><br><span class="line">           cursor = i + 1;</span><br><span class="line">           return (E) elementData[lastRet = i];</span><br><span class="line">       &#125;</span><br></pre></td></tr></table></figure><p>是在这个checkForComodification方法里面检查两个属性是否相等，如果不相等就抛出异常。可是这里有个问题，为什么在用For的时候会去调用Iterator的next方法呢。</p><h5 id="分析源码"><a href="#分析源码" class="headerlink" title="分析源码"></a>分析源码</h5><p>看看编译的Class文件。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">  public static void main(String[] args) &#123;</span><br><span class="line">      List&lt;String&gt; list = new ArrayList();</span><br><span class="line">      list.add(&quot;java01&quot;);</span><br><span class="line">      list.add(&quot;java02&quot;);</span><br><span class="line">      list.add(&quot;java03&quot;);</span><br><span class="line">      Iterator iterator = list.iterator();</span><br><span class="line"></span><br><span class="line">//正常</span><br><span class="line">      while(iterator.hasNext()) &#123;</span><br><span class="line">          if (&quot;java01&quot;.equals(iterator.next())) &#123;</span><br><span class="line">              iterator.remove();</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      Iterator var3 = list.iterator();</span><br><span class="line">//异常</span><br><span class="line">      String str;</span><br><span class="line">      while(var3.hasNext()) &#123;</span><br><span class="line">          str = (String)var3.next();</span><br><span class="line">          if (&quot;java01&quot;.equals(str)) &#123;</span><br><span class="line">              list.remove(1);</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      var3 = list.iterator();</span><br><span class="line">//异常</span><br><span class="line">      while(var3.hasNext()) &#123;</span><br><span class="line">          str = (String)var3.next();</span><br><span class="line">          if (&quot;java01&quot;.equals(str)) &#123;</span><br><span class="line">              list.add(&quot;java04&quot;);</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      System.out.println();</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>这里可以看到，我写的For循环，在编译过后变成了上述代码那样，也是使用的Iterator，至于为什么会编译成这样就不管了，来看看在哪里报的错</p><p>Iterator下面的remove</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">public void remove() &#123;</span><br><span class="line">    if (lastRet &lt; 0)</span><br><span class="line">        throw new IllegalStateException();</span><br><span class="line">    //检查modCount和expectedModCount是否相等</span><br><span class="line">    checkForComodification();</span><br><span class="line"></span><br><span class="line">    try &#123;</span><br><span class="line">    //删除掉节点</span><br><span class="line">        ArrayList.this.remove(lastRet);</span><br><span class="line">        cursor = lastRet;</span><br><span class="line">        lastRet = -1;</span><br><span class="line">        //将当前List修改的结构次数modCount赋值给预期的修改次数</span><br><span class="line">        expectedModCount = modCount;</span><br><span class="line">    &#125; catch (IndexOutOfBoundsException ex) &#123;</span><br><span class="line">        throw new ConcurrentModificationException();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个remove里面有一个赋值的过程，就是将List修改的次数modCount这个值给预期的修改次数expectedModCount，保证了两个值的相等</p><p>ArrayList下的remove</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">  public E remove(int index) &#123;</span><br><span class="line">  //检查索引</span><br><span class="line">      rangeCheck(index);</span><br><span class="line">//修改次数+1</span><br><span class="line">      modCount++;</span><br><span class="line">      E oldValue = elementData(index);</span><br><span class="line"></span><br><span class="line">      int numMoved = size - index - 1;</span><br><span class="line">      if (numMoved &gt; 0)</span><br><span class="line">          System.arraycopy(elementData, index+1, elementData, index,</span><br><span class="line">                           numMoved);</span><br><span class="line">      elementData[--size] = null; // clear to let GC do its work</span><br><span class="line"></span><br><span class="line">      return oldValue;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>其实看到这，就不用往后看了，因为在ArrayList下面的remove只是更改了modCount这个值，并没有将这个值赋值给expectedModCount，所以在下次去next的时候，去调用checkForComodification()这个方法的时候，发现modCount和expectedModCount不一致，就会抛出异常。</p><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>其实很简单的一个问题，做个记录，这里是为了安全考虑，保证了List同时只会有一个线程去更改他的结果</p>]]></content>
      
      
      <categories>
          
          <category> 随笔 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 随笔，Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>深入理解Java虚拟机 读书笔记</title>
      <link href="/%E3%80%8A%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0.html"/>
      <url>/%E3%80%8A%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0.html</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>​    最近一直在学游泳，成功的从一个旱鸭子学成了一个蛙泳健将，不错，上月把《深入理解JAVA虚拟机》看完了，一直说整理一下在本子上面的笔记，到现在发现根据遗忘曲线来说，已经忘记得差不多了，现在整理一下回顾一下，加深记忆，在过几个月在回顾，这是一个技巧。</p><p>​    工作上一直就是需求评审，需求研发，测试，改bug，上线，循环下去，但是这周接触到性能方面的问题，这是搬砖过程中难得的一次经验提升的机会，其实最后解决的方法也简单，只是加了Redis缓存而已，但是解决性能问题的过程也是挺有意思的</p><p>​    好了，不说了，开始整理笔记</p><h1 id="深入理解JAVA虚拟机"><a href="#深入理解JAVA虚拟机" class="headerlink" title="深入理解JAVA虚拟机"></a>深入理解JAVA虚拟机</h1><p>​    这本书买了很久，一直没有看，也很正常，买了好多书，都没有看，但是最近在看内存，和类加载机制的时候，发现网上的文章很多是来自本书，索性就系统学习一下，网上零碎的知识始终没有详细的了解下来有意思。</p><p>​    这本书是真的不错，值得一读，读完之后，会对JAVA虚拟机有一个全面的了解，不吹了。开始吧。</p><h2 id="自动内存管理"><a href="#自动内存管理" class="headerlink" title="自动内存管理"></a>自动内存管理</h2><h3 id="运行时数据区域"><a href="#运行时数据区域" class="headerlink" title="运行时数据区域"></a>运行时数据区域</h3><p>​    JVM在执行JAVA程序时会将内存分成不同的数据区域</p><p>​    1、程序计数器</p><p>​        字节码的行号指示器，字节码解释器通过计数器的值来选取下一条需要执行的指令</p><p>​    2、Java虚拟机栈</p><p>​        Java方法执行的内存模型，每个方法执行时都会创建一个栈帧用于存储局部变量表，操作数栈，动态链接</p><p>​    3、本地方法栈</p><p>​        为本地的Native方法服务</p><p>​    4、Java堆</p><p>​        所有的线程共享的内存区域，存放对象的实例。并且在这分配内存，该区域是垃圾收集器管理的主要区域，    也成GC堆</p><p>​    5、方法区</p><p>​        同Java堆，线程共享的内存区域，用来存加载的类信息，常量，静态变量</p><p>​    6、运行时常量池</p><p>​        方法区的一部分。static final 修饰常量</p><p>​        运行时常量：运行时确定值</p><p>​        编译期常量：编译器确定值</p><p>​        编译期常量风险：A类常量 a=1</p><p>​                                       B类常量 b=2       B类使用A类 a=1变量         A，B类同时编译，此时a=1 b=2</p><p>​                                                                    修改A类 a=3 只编译A类 此时B类的 a=1   Error</p><p>​    7、直接内存</p><p>​        避免Java堆和Native堆来回复制数据，此时是中间内存</p><h3 id="垃圾收集器"><a href="#垃圾收集器" class="headerlink" title="垃圾收集器"></a>垃圾收集器</h3><p>确定哪些对象还活着或死去</p><h4 id="确定方法"><a href="#确定方法" class="headerlink" title="确定方法"></a>确定方法</h4><h5 id="引用计数法"><a href="#引用计数法" class="headerlink" title="引用计数法"></a>引用计数法</h5><p>给对象添加引用计数器，引用+1 引用失效-1，为0时，即可被回收</p><p>缺点：难以解决循环引用</p><h5 id="可达性分析算法"><a href="#可达性分析算法" class="headerlink" title="可达性分析算法"></a>可达性分析算法</h5><p>GC Root起始点，当对象的引用链不可达到GC Root时，对象可被回收</p><p><img src="/《深入理解Java虚拟机》读书笔记/GC Root.png" alt></p><p>可用来做GC Root的对象</p><p>1、虚拟机栈中引用的变量表</p><p>2、方法区中类静态属性引用的对象</p><p>3、常量</p><p>4、Native方法</p><h5 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h5><p>JDK1.2之前只有被引用和没有被引用的状态</p><p>JDK1.2之后引用区分：</p><p>​    强引用（Strong Reference）</p><p>​    软引用（Soft Reference）</p><p>​    弱引用（Weak Reference）</p><p>​    虚引用（Phantom Reference）</p><p>强引用：只要强引用还存在，GC就不会被回收，JAVA虚拟机抛出OOM也不会回收 实现方法 New xx 如果需要回收，则将对象设置为null 例如ArrayList  clear方法将elementData[i]=null</p><p>软引用：软引用会在内存不足的时候去回收，就是在OOM之前，会去清空对象</p><p>​    一般配合队列使用，下面代码就是配合引用队列使用</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//定义一个引用对象        </span></span><br><span class="line">ReferenceQueue&lt;String&gt; referenceQueue = <span class="keyword">new</span> ReferenceQueue&lt;&gt;();</span><br><span class="line">      String str = <span class="keyword">new</span> String(<span class="string">"abc"</span>);</span><br><span class="line">      SoftReference&lt;String&gt; softReference = <span class="keyword">new</span> SoftReference&lt;&gt;(str, referenceQueue);</span><br><span class="line">      str = <span class="keyword">null</span>;</span><br><span class="line">      <span class="comment">// Notify GC   通知GC,此时软引用没有被回收，因为被回收之后，引用队列的poll方法返回队列头元素</span></span><br><span class="line"><span class="comment">//打印输出reference为null,表示软引用没有被回收</span></span><br><span class="line">      System.gc();</span><br><span class="line">      System.out.println(softReference.get()); <span class="comment">// abc</span></span><br><span class="line">      Reference&lt;? extends String&gt; reference = referenceQueue.poll();</span><br><span class="line">      System.out.println(reference); <span class="comment">//null</span></span><br></pre></td></tr></table></figure><p>弱引用：相比软引用，拥有更短的生命周期，无论是内存是否足够，都会被回收，使用方法和软引用一样</p><p>虚引用：形同虚设，任何时候都会被回收，必须和引用队列联合使用，当垃圾回收器准备回收对象时，会在这之前将虚引用加到引用队列中 。用处：判断对象的垃圾回收</p><p><img src="/《深入理解Java虚拟机》读书笔记/引用.png" alt></p><h5 id="finalize方法"><a href="#finalize方法" class="headerlink" title="finalize方法"></a>finalize方法</h5><p>GC在回收对象前调用该方法</p><p>任何对象的finalize方法只会被系统调用一次</p><p>不建议使用</p><h4 id="垃圾收集算法"><a href="#垃圾收集算法" class="headerlink" title="垃圾收集算法"></a>垃圾收集算法</h4><h5 id="标记-清除"><a href="#标记-清除" class="headerlink" title="标记-清除"></a>标记-清除</h5><p>1、标记需要回收的对象 </p><p>2、清除标记的对象</p><p>缺点：效率，空间：会产生大量不连续的内存碎片，如果需要分配较大的对象则没有空间</p><h5 id="复制"><a href="#复制" class="headerlink" title="复制"></a>复制</h5><p>1、将内存空间分为两份，不同比例</p><p>2、将存活的对象移动到另一块内存区域</p><p>3、将已使用的内存区域清理掉</p><p>缺点：内存可使用的区域变小</p><h5 id="标记-整理"><a href="#标记-整理" class="headerlink" title="标记-整理"></a>标记-整理</h5><p>将存活的对象移动到一端，另一端清理屌</p><h5 id="分代收集"><a href="#分代收集" class="headerlink" title="分代收集"></a>分代收集</h5><p>Java堆分为新生代，老年代。不同年代使用不同算法，新生代有大量对象死亡，少量存活，则可以使用复制算法</p><p>老年代对象存活率高，可以使用标记-清理，整理算法</p><h4 id="内存分配与回收策略"><a href="#内存分配与回收策略" class="headerlink" title="内存分配与回收策略"></a>内存分配与回收策略</h4><p>对象优先分配到Eden区 新生区，当Eden区没有足够的空间，会触发minor GC，新生代GC(minor GC)</p><p>如果新生代GC没有可回收对象，采用担保机制就将新生代里面的对象移到老年代去，长期存活的对象进入老年代</p><p>-xx:maxTenuringThreshold 熬过一次MinorGc 年龄+1 超过设置的值就移到老年代去  改变这个值的大小，就表示，熬过几次新生代GC就移到老年代去</p><h5 id="空间分配担保"><a href="#空间分配担保" class="headerlink" title="空间分配担保"></a>空间分配担保</h5><p>MinorGC前检查老年代最大的连续空间是否大于新生代的所有对象空间，如果大于，则MinroGC安全，如果小于，HandlerPormotionFailare 是否允许担保失败，如果允许，检查历次晋升到老年代的对象是否小于老年代最大的连续空间，如果是，则尝试minorGC，如果不允许担保失败，不冒险。则FullGC</p><h4 id="垃圾收集器-1"><a href="#垃圾收集器-1" class="headerlink" title="垃圾收集器"></a>垃圾收集器</h4><p>不同厂商，不同版本的虚拟机所提供的垃圾收集器有很大区别，不同场景，不同应用有最适合的垃圾收集器</p><h5 id="serial"><a href="#serial" class="headerlink" title="serial"></a>serial</h5><p>新生代收集器，采用标记复制收集算法，单线程，并不是指单线程，而是在一个CPU在执行GC时。必须暂停其它工作线程</p><h5 id="serial-old"><a href="#serial-old" class="headerlink" title="serial old"></a>serial old</h5><p>老年代收集器，采用标记整理收集算法，和serial收集器类似，是单线程</p><h5 id="parNew"><a href="#parNew" class="headerlink" title="parNew"></a>parNew</h5><p>serial收集器的多线程版本，server模式下的新生代收集器，只有CMS收集器能配合工作</p><p>（并行与并发的概念）并行   parallel  </p><p>多条垃圾收集器多线程并行工作，此时用户线程任然处于等待状态</p><p>并发 concurrent</p><p>值用户线程与垃圾收集器线程同时工作（可能不是并行，可能会交替进行）用户线程继续运行，垃圾收集器线程运行在另一个CPU上</p><h5 id="parallel-scavenge-收集器"><a href="#parallel-scavenge-收集器" class="headerlink" title="parallel scavenge 收集器"></a>parallel scavenge 收集器</h5><p>新生代收集器，采用复制算法，并行多线程收集器</p><p>关注点：CMS等收集器，缩短GC时用户线程停顿时间。parallel scavenge控制吞吐量</p><p>两个参数精确控制吞吐量</p><p>-xx:MaxGcpauseMillis 大于0的毫秒数</p><p>保证内存回收的时间控制在设定值,GC停顿时间是牺牲吞吐量和新生代的空间换取</p><p>-xx:GcTimePatio   0-100整数</p><p>垃圾收集所暂用总时间的比例</p><h5 id="parallel-old收集器"><a href="#parallel-old收集器" class="headerlink" title="parallel old收集器"></a>parallel old收集器</h5><p>老年代收集器，采用标记整理算法</p><h5 id="CMS收集器"><a href="#CMS收集器" class="headerlink" title="CMS收集器"></a>CMS收集器</h5><p>CMS (cancurrent Mark sweep)</p><p>获取最短回收停顿时间为目标的收集器，互联网站或B/S系统适用，提升响应速度，系统停顿时间最短</p><p>Mark sweep 标记-清除</p><p>整个过程4个步骤</p><p>初始标记 CMS initial mark    需要STW （stop the world）</p><p>并发标记 CMS concurrent mark</p><p>重新标记 CMS rement   需要STW （stop the world）</p><p>并发清除 CMS concurrent sweep</p><p>初始标记，重新标记人需要stop the world</p><p>初始标记只需要标记GC Root能关联的对象，并发标记就是GC Root跟踪的一个过程</p><p>重新标记则是记录在并发标记期间，用户继续运作产生变动的一部分对象，停顿时间比初始标记长，远比并发标记段</p><p>整个过程耗时最长的并发标记和并发清除是可以和用户线程一起工作</p><p>CMS收集器内存回收可以与用户线程一起工作</p><p>CMS收集器特点：并发收集，低停顿</p><p>缺点：1、对CPU资源敏感</p><p>并发回收时，占用CPU资源的25%以上，随着CPU数量的增加而下降，当CPU是2个回收时，占用资源达到50%</p><p>2、无法处理浮动垃圾</p><p>并发清理阶段，用户线程还会产生新的垃圾（浮动垃圾）</p><p>3、CMS基于标记-清除算法实现，会产生大量的空间碎片</p><p>分配大对象会触发FullGC</p><p>+usecmscompactAtFullCollection 默认开启</p><p>在要FullGC时会整理内存空间，空间碎片没了，停顿时间会变长</p><h5 id="G1收集器"><a href="#G1收集器" class="headerlink" title="G1收集器"></a>G1收集器</h5><p>特点：并行 并发 分代收集 空间整理</p><p>G1从整体上看是基于标记整理算法。G1将Java堆分为若干Region ,标记整理Region</p><p>从局部来看是基于复制算法（两个Region）</p><p>可预测的停顿</p><p>G1收集器之前，收集范围都是整个新生代和老年代，G1在堆得布局与其他有很大区别</p><p>将Java堆分为多个大小相等的独立区域 Region，根据各个region的可回收的垃圾价值决定所有可预测停顿的时长，G1收集器化整为零 将Java堆分为多个大小相同的region</p><p>G1收集器运行步骤：<br>初始标记，并发标记，最终标记，筛选回收  类似CMS回收步骤，筛选回收则是根据Region的可回收价值来针对回收</p><h3 id="虚拟机执行子系统"><a href="#虚拟机执行子系统" class="headerlink" title="虚拟机执行子系统"></a>虚拟机执行子系统</h3><h4 id="虚拟机类加载机制"><a href="#虚拟机类加载机制" class="headerlink" title="虚拟机类加载机制"></a>虚拟机类加载机制</h4><h5 id="类加载时机"><a href="#类加载时机" class="headerlink" title="类加载时机"></a>类加载时机</h5><p>生命周期</p><p>加载-&gt;验证-&gt;准备-&gt;解析-&gt;初始化-&gt;使用-&gt;卸载</p><p>加载、验证、准备、初始化、卸载这5个阶段顺序是确定，解析为支持Java动态绑定而不规定什么时候进行</p><p>只有5中情况必须对类立即进行初始化，包括初始化之前的加载，验证，准备阶段</p><p>1、new 读取或设置一个静态字段，以及调用静态方法</p><p>2、对类进行反射时</p><p>3、初始化一个类时发现父类还没有初始化，则先需要初始化父类</p><p>4、虚拟机启动时的主类，包含main的类</p><p>5、方法句柄所对应的类没有进行初始化，则需要先触发其初始化</p><p>有且只有上述5种方法称之为主动引用</p><p>3种被动引用</p><p>1、通过子类引用父类的静态字段，不会导致子类初始化 P211代码</p><p>2、通过数组定义来引用类，不会触发初始化 P212代码</p><p>3、常量在编译阶段会存入调用类的常量池中，本质并没有直接引用定义的常量的类，不会触发定义常量的类的初始化 P213代码</p><p>接口与类不同，接口并不要求其父接口全部完成初始化，只有在使用到父接口中定义的常量是才会初始化</p><h5 id="类加载过程"><a href="#类加载过程" class="headerlink" title="类加载过程"></a>类加载过程</h5><h6 id="加载"><a href="#加载" class="headerlink" title="加载"></a>加载</h6><p>1、通过类的全限定名来获取此类的二进制流</p><p>2、将字节流所代表的的静态存储结构转换为方法区的运行时数据结构</p><p>3、在内存中生成一个代表这个类的Class对象，作为方法区这个类的各种数据的访问入口</p><p>获取Class文件来源</p><ol><li>ZIP包中获取 最常见</li><li>网络中获取</li><li>运行时计算生成 动态代理</li><li>有其他文件生成 有jsp文件生成的class类</li><li>有数据库读取</li></ol><p>可重写loadclass()方法自定义不同的类加载器</p><h6 id="验证"><a href="#验证" class="headerlink" title="验证"></a>验证</h6><p>确保Class文件的字节流中包含信息符合当前虚拟机要求，不会危害虚拟机自身安全</p><p>4个检验动作</p><p>文件格式验证，元数据验证，字节码验证，符号引用验证</p><p>1、文件格式验证</p><p>验证字节流是否符合Class文件格式规范，并且能被当前版本的虚拟机处理</p><p>验证点：是否以魔数开头，主次版本号是否在当前虚拟机的处理范围，常量池中的常量是否有不被支持的常量类型，是否有指向不存在的常量，或不符合类型的常量，Class文件中各部分以及文件本身是否有被删除或附加其他信息</p><p>2、元数据验证</p><p>是对字节码描述的信息进行语义分析确保指定的信息符合Java语言规范</p><p>验证点包括：</p><ol><li>是否有父类（除了Object外，所有类都有父类）</li><li>这个类是否集成了不允许被继承的类（被final修饰）</li><li>如果不是抽象类，是否实现了父类或接口中要求实现的所有方法</li><li>类中的字段方法是否与父类产生矛盾，比如覆盖了父类的final字段</li></ol><p>3、字节码验证</p><p>最重要的验证环节，通过数据流和控制流分析，确保语义合法，符合逻辑，针对方法体进行校验分析，保证方法运行时不会做出危害虚拟机的安全事件</p><p>4、符号验证</p><p>符号引用验证看做是对类自身以外的信息进行匹配校验</p><h6 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h6><p>准备阶段是正式为类变量分配内存并设置类变量初始值阶段，此时分配内存仅分配被static修饰的变量，设置默认值只是设置value的零值</p><h6 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h6><p>符号引用：以一组符号来描述所引用的目标，符号可以是任何形式的字面量</p><p>直接引用：可以直接指向目标的指针，相对偏移量，或是一个能间接定位到目标的句柄</p><p>解析阶段就是虚拟机将常量池内的符号引用转换为直接引用的过程，解析动作主要针对类和接口，字段，类方法，接口方法，方法类型，方法句柄</p><h6 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h6><p>类加载过程中最后一步，初始化阶段为类的静态变量赋予正确的初始值</p><h4 id="类加载器"><a href="#类加载器" class="headerlink" title="类加载器"></a>类加载器</h4><h5 id="类和类加载器"><a href="#类和类加载器" class="headerlink" title="类和类加载器"></a>类和类加载器</h5><p>任意一个类需要由他的类加载器和类的本身确定在虚拟机中的唯一性，比较两个类是否相等，只有在两个类都是由同一个类加载器的前提下比较才有意义</p><h5 id="双亲委派模型"><a href="#双亲委派模型" class="headerlink" title="双亲委派模型"></a>双亲委派模型</h5><p><img src="/《深入理解Java虚拟机》读书笔记/双亲委派模型.png" alt></p><p>双亲委派模型要求：</p><p>除了顶层的启动类加载器外，其余的类加载器都必须有自己的父类加载器</p><p>双亲委派模型工作过程：</p><p>如果一个类加载器收到了类加载器的请求，他首先不会自己去尝试加载这个类，而是把请求委派给父类去加载，每个层次的类加载器都是如此，因此所有的加载请求，最终都应该传送到顶层的启动类加载器中，只有当父类加载器反馈自己无法完成这个加载请求（搜索范围内没有所需的类）时，自家在其才会尝试自己加载</p><p>双亲委派模型好处：<br>带有优先级的层次关系，保证子类加载器不会和父类加载器加载到重复的类，从而保证类的唯一性</p><p>双亲委派模型的实现：</p><p>P232代码</p><h2 id="Java内存模型"><a href="#Java内存模型" class="headerlink" title="Java内存模型"></a>Java内存模型</h2><h4 id="主内存和工作内存"><a href="#主内存和工作内存" class="headerlink" title="主内存和工作内存"></a>主内存和工作内存</h4><p>Java内存模型规定所有的变量都存在主内存上，每条线程还会有自己的工作内存，工作内存保存了被该线程使用到的变量的主内存拷贝，线程的所有操作都在工作内存完成，不能直接读写主内存中的变量，不同线程无法直接访问对方的工作内存</p><p><img src="/《深入理解Java虚拟机》读书笔记/内存模型.png" alt></p><h4 id="内存间相互调用"><a href="#内存间相互调用" class="headerlink" title="内存间相互调用"></a>内存间相互调用</h4><p>主内存和工作内存的相互操作</p><p>lock 锁定：作用于主内存，把一个变量标识为线程独占</p><p>unlock 解锁：作用于主内存，把一个锁定的变量解锁</p><p>read 读取：作用于主内存，把主内存的值传输到工作内存，以便随后的load操作</p><p>load 载入：作用于工作内存，把read操作从主内存得到的变量放入工作内存的副本</p><p>use 使用：作用于工作内存，将工作内存中的一个变量传递给执行引擎，虚拟机需要使用变量时会执行这个操作</p><p>assign 赋值：作用于工作内存，将执行引擎街道的值赋值给工作内存</p><p>store 存储：作用于工作内存的变量，把工作内存的变量值传递到主内存，以便随后的write操作</p><p>write 写入：作用于主内存，把store操作从工作内存得到的变量值放入主内存</p><p>Java内存模型规定了执行上述8种基本操作时，必须满足一下规则来保证内存操作在并发条件下时安全的</p><ol><li><p>不允许read和load，store和write操作之一单独出现，即变量存主内存读取了但工作内存不接受，或从工作内存发起了回写，但主内存不接受</p></li><li><p>不允许一个线程丢弃他最近的assign操作，即变量在工作内存中改变了，必须把该变化同步回主内存</p></li><li><p>不允许一个线程无原因的（没有assign操作）把数据从工作内存同步到主内存</p></li><li><p>新的变量只能在主内存中”诞生“，不允许在工作内存中直接使用一个未被初始化，load,assign的变量，对变量实施use，store操作前必须执行了assign赋值和load载入操作</p></li><li><p>一个变量在同一时刻只允许一条线程对其进行load操作，但lock操作可以被同一条线程重复执行多次，多次lock之后，只有执行相同次数的unlock操作，变量才会被解锁</p></li><li><p>对变量执行lock操作会清空工作内存中此变量的值，在使用时需要重新执行load或assign初始化变量的值</p></li><li><p>如果变量没有被lock操作锁定，不允许unlock操作，也不允许unlock一个被其他线程锁定的变量</p></li><li><p>对变量unlock操作之前，必须把变量同步回主内存中执行store,write操作</p></li></ol><h4 id="volatile型变量的特殊规则"><a href="#volatile型变量的特殊规则" class="headerlink" title="volatile型变量的特殊规则"></a>volatile型变量的特殊规则</h4><p>变量定义为volatile之后有两种特性</p><p>1、保证此变量堆所有线程的可见性</p><p>​    可见性是指当一个线程修改了变量的值，新值对于其他线程时立即可知的，但不能保证变量的原子性，因为Java里面的运算并非原子操作。</p><p>​    在必要时还是需要通过加锁来保证原子性：1、运算结果不依赖变量当前的值或者确保只有单一线程修改变量的值。2、变量不需要与其他变量共同参与不变约束</p><p>2、禁止指令重排</p><p>普通变量仅会保证结果正确，不能保证赋值操作的顺序与程序代码中的执行顺序一致，简单的理解为禁止虚拟机优化字节码的顺序排列而导致结果异常</p><h4 id="Java内存模型对Volatile变量定义的特殊规则"><a href="#Java内存模型对Volatile变量定义的特殊规则" class="headerlink" title="Java内存模型对Volatile变量定义的特殊规则"></a>Java内存模型对Volatile变量定义的特殊规则</h4><p>T线程  V,W为volatile变量</p><p>1、只有T执行的前一个动作是load载入时，线程T才能对变量执行use使用操作，并且T对V执行的后一个动作是use使用时，T才能对v执行load操作。</p><p>T对V的use动作可以认为T对V的load，read动作相关联，必须连续一起出现，这条规则要求在工作内存中，每次使用V时都必须从主内存刷新最新的值，保证能看见其他线程对变量V的操作</p><p>2、T对变量V的前一个动作是assign赋值时，T才能对变量V执行store存储动作，并且T对V执行的后一个动作是store时，T才能对V执行assign，T对V的assign操作可以认为T对V的store，write相关联，必须连续出现，保证其他线程可以看到自己对V的修改</p><p>3、保证代码的执行顺序与程序时相同的</p><h4 id="long-double特殊规则"><a href="#long-double特殊规则" class="headerlink" title="long double特殊规则"></a>long double特殊规则</h4><p>64位数据类型，long double</p><p>允许虚拟机将没有被volatile修饰的变量的64位数据读写操作划分为两次32位操作，即虚拟机可以选择不保证64位数据类型的load，store，read，write4个操作的原子性，即long，double的非原子性协议，由于商用虚拟机都选择把64位数据读写操作作为原子操作，因此不需要把long，double变量专门声明位volatile</p><h4 id="原子性，可见性，有序性"><a href="#原子性，可见性，有序性" class="headerlink" title="原子性，可见性，有序性"></a>原子性，可见性，有序性</h4><h5 id="原子性"><a href="#原子性" class="headerlink" title="原子性"></a>原子性</h5><p>read,load,assign,use,store,write</p><p>基本数据类型的访问读写是具备原子性，lock unlock也是，但并未开放给用户使用，但提供了更高层次的字节码指令 monitorenter和monitorexit，反映到Java代码就是synchroized</p><h5 id="可见性"><a href="#可见性" class="headerlink" title="可见性"></a>可见性</h5><p>指当一个线程修改了共享变量的值，其他线程能立即知道修改，无论是普通变量还是volatile变量都是变量修改后将新值同步回主内存，读取变量前从主内存刷新变量值，普通变量和volatile的区别是volatile的特殊规则保证了新值能立即同步回主内存，出volatile之外，Java还有两个关键字实现了可见性 synchroized和final，synchroized是由对一个变量的unlock操作之前必须把此变量同步回主内存执行store，write操作，final可见性，不能更改</p><h5 id="有序性"><a href="#有序性" class="headerlink" title="有序性"></a>有序性</h5><p>Java程序中天然的有序性可以总结为一句话：如果本线程内观察多有操作都是有序的，如果在一个线程中观察另一个线程所有操作都是无序的。前一句：线程内表现为串行的语义，后一句：指令重排序，工作内存和主内存同步延迟，volatile本身就包含禁止指令重排序，synchreized是一个时刻只允许一个县城对其进行load操作</p><h4 id="先行发生原则-happens-before"><a href="#先行发生原则-happens-before" class="headerlink" title="先行发生原则 happens-before"></a>先行发生原则 happens-before</h4><p>他是判断数据是否存在竞争，县城是否安全的主要依据</p><p>天然的先行发生原则：</p><p>1、程序次序规则：在一个线程内按照程序代码顺序，书写在前面的操作先行发生于书写在后面的操作，准确的说是控制流顺序，而不是程序代码的顺序，因为要考虑到分支循环操作</p><p>2、管道锁定规则：在一个unlock操作先行发生于后面对同一个锁的lock操作</p><p>3、volatile变量规则：对一个volatile变量的写操作先行发生于后面的这个变量的读操作</p><p>4、线程启动规则：Threa对象的stat方法先行发生于此线程的每一个动作</p><p>5、线程终止规则：线程中的所有操作都先行发生于此线程的终止检测，通过Thread.join方法结束</p><p>6、线程终端规则：对线程的interrupt方法调用先行发生与中断线程的代码检测到的中断事件的发生 ，通过Thead.inrerrupt方法检测到是否有中断发生</p><p>7、对象终结规则：一个对象的初始化完成（构造函数）执行结束先行发生于他的finalize方法的开始</p><p>8、传递性：如果动作A先行发生与动作B，动作B先行发生于动作C，可以得出动作A先行发生于动作C</p><p>上述可以得出一个结论，时间先后顺序与先行发生原则之间基本没有太大的关系，所以衡量并发安全问题的时候不要受到时间顺序的干扰，一切必须以先行发生原则为准</p><h2 id="Java线程状态转换"><a href="#Java线程状态转换" class="headerlink" title="Java线程状态转换"></a>Java线程状态转换</h2><p>Java定义了5种线程状态在任意时间点，一个线程只能有且只有一种状态</p><p>新建 new ：创建尚未启动的线程处于这种状态</p><p>运行 Runable 处于此线程有可能正在执行，也有可能正在等待CPU为他分配执行时间</p><p>无限期等待：waiting处于这种状态的线程不会被分配CPU，执行时间要等待其他线程的显示唤醒，以下方法会让线程陷入无限期等待状态：没有设置Timeout参数的Object.wait，没有设置Timeout参数的Thread.join，LockSupport.park方法</p><p>限期等待 （Time，waiting）：不会被分配CPU执行时间，无需等待被其他线程显示的唤醒，在一定时间之后由系统自动唤醒，在一定时间之后由系统自动唤醒，以下方法会让线程进入限期等待状态：Thread.sleep，设置了Timeout参数的Object.wait，设置了Timeout参数的Thread.join，Locksupport.parkNans方法，LockSupport.parkuntil方法</p><p>阻塞 Blocked:阻塞状态与等待状态的区别是：阻塞状态在等待获取到一个排它锁，这个事件将在另外一个线程放弃这个锁的时候发生，等待状态则是在等待一段时间或者唤醒动作发生时，在线程等待进入同步区域时线程将进入这种状态</p><p>结束 Terminated:已终止线程的线程状态，线程以结束运行</p><p><img src="/《深入理解Java虚拟机》读书笔记/线程状态.png" alt></p><p>线程安全程序由强至弱来排序分为5类</p><p>1、不可变：被final修饰的变量，因为其不可变，所以永远不会看到多个线程之中处于不一致的状态，不可变带来的线程安全性是最简单最纯粹的</p><p>2、绝对线程安全：被sync修饰的，尽管效率低，但确实是安全的</p><p>3、相对线程安全：相对安全就是我们通常意义上所讲的线程安全，大部分线程安全都属于这种类型，Vector,HashTable</p><p>4、线程兼容：线程兼容是指对象本身并不是线程安全，但是可以通过调用端正确的使用同步手段来保证对象在并发环境中的安全，hashMap,ArrayList</p><p>5、线程对立：线程对立是指无论调用端是否采取了同步措施，都无法在多线程中并发使用的代码，应避免出现这种情况</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>​     整理了关于这本书的读书笔记，挺不错的，都是理论知识，花了一个多月时间，对JVM大致有了一个了解，虽然工作中涉及到的不多，但在以后的面试中，或者以后工作中，对于Java的深入会有一定帮助，多读书总是没错的。</p><p>​     最近工（划）作（水）中随便学习了一些零乱的东西，比如myabtis的二级缓存，Redis的pipline管道等，总之很杂乱，但是看过就忘了，所以以后要将零碎的东西也整理一下，至少看过了，做个笔记，时间久了，会看到这一路走来，接触的东西有一个总结</p><p>​     至于工作嘛！！！老样子，开会，研发，测试，没什么惊喜，但是有个感触，在和大数据对接的过程中，大数据研发工程师是武大研究生，好生羡慕，在对话的过程中，发现差距还是很大的，他说的redis的pipline，在之前没听说过,所以我才去研究，以及一些在我看来的高端术语，听得我一脸懵逼。哎，加油吧！</p><p>​     面朝大海，春暖花开！</p>]]></content>
      
      
      <categories>
          
          <category> JAVA </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 读书笔记，JAVA </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ReentrantLock源码浅谈</title>
      <link href="/ReentrantLock%E6%BA%90%E7%A0%81%E6%B5%85%E8%B0%88.html"/>
      <url>/ReentrantLock%E6%BA%90%E7%A0%81%E6%B5%85%E8%B0%88.html</url>
      
        <content type="html"><![CDATA[<h4 id="开始之前"><a href="#开始之前" class="headerlink" title="开始之前"></a>开始之前</h4><p> 最近一直没有写东西，两个原因 一:前段时间工作太忙，再加上办了一张游泳卡，近期都在去游泳，二:所有的输出都输出到纸上去了</p><p>深入理解Java虚拟机这本书买来一直吃灰状态中，最近拜读完，并且做了笔记。发现一个问题，很多博客上面的内容都是来自此书，而且都是断断续续的，建议如果需要系统的了解JVM,还是买来看一看</p><p>有时间将笔记上的内容copy到网上，最近无事，准备看看JUC (java.util.concurrent)里面的内容，然后结合Java并发编程的艺术，来看看Java并发是怎么一回事</p><h4 id="开始"><a href="#开始" class="headerlink" title="开始"></a>开始</h4><h5 id="是什么？"><a href="#是什么？" class="headerlink" title="是什么？"></a>是什么？</h5><p>ReentrantLock是一个可重入的互斥锁，又被称为独占锁。ReentrantLock锁在同一时间点只能被一个线程锁持有，而可重入的意思是，ReentrantLock锁可以被单个线程多次获取</p><p>ReentrantLock可以分为<strong>公平锁</strong>和<strong>非公平锁</strong> ，公平锁：通过一个FIFO等待队列来管理获取该锁的所有线程，保证线程先进先出。非公平锁：在锁是可获取状态时，任何线程都有可能获取到该锁。</p><h5 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">// 创建一个 ReentrantLock ，默认是“非公平锁”。</span><br><span class="line">ReentrantLock()</span><br><span class="line">// 创建策略是fair的 ReentrantLock。fair为true表示是公平锁，fair为false表示是非公平锁。</span><br><span class="line">ReentrantLock(boolean fair)</span><br><span class="line"></span><br><span class="line">// 查询当前线程保持此锁的次数。</span><br><span class="line">int getHoldCount()</span><br><span class="line">// 返回目前拥有此锁的线程，如果此锁不被任何线程拥有，则返回 null。</span><br><span class="line">protected Thread getOwner()</span><br><span class="line">// 返回一个 collection，它包含可能正等待获取此锁的线程。</span><br><span class="line">protected Collection&lt;Thread&gt; getQueuedThreads()</span><br><span class="line">// 返回正等待获取此锁的线程估计数。</span><br><span class="line">int getQueueLength()</span><br><span class="line">// 返回一个 collection，它包含可能正在等待与此锁相关给定条件的那些线程。</span><br><span class="line">protected Collection&lt;Thread&gt; getWaitingThreads(Condition condition)</span><br><span class="line">// 返回等待与此锁相关的给定条件的线程估计数。</span><br><span class="line">int getWaitQueueLength(Condition condition)</span><br><span class="line">// 查询给定线程是否正在等待获取此锁。</span><br><span class="line">boolean hasQueuedThread(Thread thread)</span><br><span class="line">// 查询是否有些线程正在等待获取此锁。</span><br><span class="line">boolean hasQueuedThreads()</span><br><span class="line">// 查询是否有些线程正在等待与此锁有关的给定条件。</span><br><span class="line">boolean hasWaiters(Condition condition)</span><br><span class="line">// 如果是“公平锁”返回true，否则返回false。</span><br><span class="line">boolean isFair()</span><br><span class="line">// 查询当前线程是否保持此锁。</span><br><span class="line">boolean isHeldByCurrentThread()</span><br><span class="line">// 查询此锁是否由任意线程保持。</span><br><span class="line">boolean isLocked()</span><br><span class="line">// 获取锁。</span><br><span class="line">void lock()</span><br><span class="line">// 如果当前线程未被中断，则获取锁。</span><br><span class="line">void lockInterruptibly()</span><br><span class="line">// 返回用来与此 Lock 实例一起使用的 Condition 实例。</span><br><span class="line">Condition newCondition()</span><br><span class="line">// 仅在调用时锁未被另一个线程保持的情况下，才获取该锁。</span><br><span class="line">boolean tryLock()</span><br><span class="line">// 如果锁在给定等待时间内没有被另一个线程保持，且当前线程未被中断，则获取该锁。</span><br><span class="line">boolean tryLock(long timeout, TimeUnit unit)</span><br><span class="line">// 试图释放此锁。</span><br><span class="line">void unlock()</span><br></pre></td></tr></table></figure><h4 id="源码结构"><a href="#源码结构" class="headerlink" title="源码结构"></a>源码结构</h4><p>ReentrantLock实现了Lock接口</p><p>ReentrantLock的锁实现机制是通过Sync实现的。Sync下有两个子类  FairSync （公平锁）和 NonfairSync （非公平锁）</p><p>Sync又是AQS的子类</p><h5 id="节点数据结构"><a href="#节点数据结构" class="headerlink" title="节点数据结构"></a>节点数据结构</h5><p>Node是CLH队列的节点，代表等待锁的线程队列</p><p>每个Node都会对应一个线程，每个Node的prev和next都会对应等待队列的上一个线程和下一个线程</p><p>Node通过waitStatus来判断线程的等待状态，具体的状态下文表格中有</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line">static final class Node &#123;</span><br><span class="line">        static final Node SHARED = new Node();</span><br><span class="line">        static final Node EXCLUSIVE = null;</span><br><span class="line"></span><br><span class="line">        /**线程已被取消的状态*/</span><br><span class="line">        static final int CANCELLED =  1;</span><br><span class="line">        /** 正常等待状态，需要被唤醒 */</span><br><span class="line">        static final int SIGNAL    = -1;</span><br><span class="line">        /** 线程处于条件判断状态 */</span><br><span class="line">        static final int CONDITION = -2;</span><br><span class="line">        /**</span><br><span class="line">         * waitStatus value to indicate the next acquireShared should</span><br><span class="line">         * unconditionally propagate</span><br><span class="line">         */</span><br><span class="line">        static final int PROPAGATE = -3;</span><br><span class="line"></span><br><span class="line">        /**</span><br><span class="line">         *上述几种状态</span><br><span class="line">         */</span><br><span class="line">        volatile int waitStatus;</span><br><span class="line"></span><br><span class="line">        /**</span><br><span class="line">         * 当前节点的上一个节点</span><br><span class="line">         */</span><br><span class="line">        volatile Node prev;</span><br><span class="line"></span><br><span class="line">        /**</span><br><span class="line">         * 当前节点的下一个节点</span><br><span class="line">         */</span><br><span class="line">        volatile Node next;</span><br><span class="line"></span><br><span class="line">        /**</span><br><span class="line">         * 节点对应的线程</span><br><span class="line">         */</span><br><span class="line">        volatile Thread thread;</span><br><span class="line"></span><br><span class="line">        /**</span><br><span class="line">         * 在有条件判断时的串行队列</span><br><span class="line">         */</span><br><span class="line">        Node nextWaiter;</span><br><span class="line"></span><br><span class="line">        /**</span><br><span class="line">         * 判断是否共享</span><br><span class="line">         */</span><br><span class="line">        final boolean isShared() &#123;</span><br><span class="line">            return nextWaiter == SHARED;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        /**</span><br><span class="line">         * 返回当前节点的上一个节点</span><br><span class="line">         *</span><br><span class="line">         * @return the predecessor of this node</span><br><span class="line">         */</span><br><span class="line">        final Node predecessor() throws NullPointerException &#123;</span><br><span class="line">            Node p = prev;</span><br><span class="line">            if (p == null)</span><br><span class="line">                throw new NullPointerException();</span><br><span class="line">            else</span><br><span class="line">                return p;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Node() &#123;    // Used to establish initial head or SHARED marker</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">// 构造函数，构造一个当前线程的节点，mode表示是独占还是共享</span><br><span class="line">        Node(Thread thread, Node mode) &#123;     // Used by addWaiter</span><br><span class="line">            this.nextWaiter = mode;</span><br><span class="line">            this.thread = thread;</span><br><span class="line">        &#125;</span><br><span class="line">//构造函数，thread是当前现场，waitStatus是线程的等待状态</span><br><span class="line">        Node(Thread thread, int waitStatus) &#123; // Used by Condition</span><br><span class="line">            this.waitStatus = waitStatus;</span><br><span class="line">            this.thread = thread;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h3 id="源码"><a href="#源码" class="headerlink" title="源码"></a>源码</h3><h4 id="结构图"><a href="#结构图" class="headerlink" title="结构图"></a>结构图</h4><p><img src="/ReentrantLock源码浅谈/类结构图.png" alt></p><p>ReentrantLock的锁实现机制是有Sync类具体实现的</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">/** Synchronizer providing all implementation mechanics */</span><br><span class="line">    private final Sync sync;</span><br></pre></td></tr></table></figure><p>从这里可以看出来，在实例化一个ReentrantLock的时候默认是实例化一个非公平锁的，可以选择当前锁是使用公平锁还是非公平锁</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line">     * 实例化一个非公平锁</span><br><span class="line">     * This is equivalent to using &#123;@code ReentrantLock(false)&#125;.</span><br><span class="line">     */</span><br><span class="line">    public ReentrantLock() &#123;</span><br><span class="line">        sync = new NonfairSync();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 根据fair参数选择创建公平锁或非公平锁</span><br><span class="line">     *</span><br><span class="line">     * @param fair &#123;@code true&#125; if this lock should use a fair ordering policy</span><br><span class="line">     */</span><br><span class="line">    public ReentrantLock(boolean fair) &#123;</span><br><span class="line">        sync = fair ? new FairSync() : new NonfairSync();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h4 id="加锁"><a href="#加锁" class="headerlink" title="加锁"></a>加锁</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * ReentrantLock里面的lock方法，其实是调用的Sync里面的lock方法</span><br><span class="line"> */</span><br><span class="line">public void lock() &#123;</span><br><span class="line">       sync.lock();</span><br><span class="line">   &#125;</span><br><span class="line">   </span><br><span class="line">   /**</span><br><span class="line"> * 这个是Sync里面的抽象方法，在ReentrantLock里面调用的就是这个</span><br><span class="line"> */</span><br><span class="line">   abstract void lock();</span><br></pre></td></tr></table></figure><p>这里是父类实现的抽象方法，具体实现在两个子类里面，就是NonfairSync和FairSync里面</p><h5 id="非公平锁加锁"><a href="#非公平锁加锁" class="headerlink" title="非公平锁加锁"></a>非公平锁加锁</h5><p>非公平锁加锁是每次都会尝试获取锁，如果获取成功了，就直接返回，如果没有成功，就会添加到等待队列</p><p>所以非公平锁在第一次没有获取成功时，加入等待队列之后也和公平锁没什么区别</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Sync object for non-fair locks</span><br><span class="line"> */</span><br><span class="line">static final class NonfairSync extends Sync &#123;</span><br><span class="line">    private static final long serialVersionUID = 7316153563782823691L;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * Performs lock.  Try immediate barge, backing up to normal</span><br><span class="line">     * acquire on failure.</span><br><span class="line">     */</span><br><span class="line">    final void lock() &#123;</span><br><span class="line">    //因为这里是非公平锁，首先用CAS抢占锁。如果成功则保存当前线程，不成功就走锁竞争的逻辑</span><br><span class="line">    //通过CAS修改状态，如果能将状态值修改为1，则表示获取锁成功</span><br><span class="line">        if (compareAndSetState(0, 1))  </span><br><span class="line">        //讲当前线程存起来，供后续使用</span><br><span class="line">            setExclusiveOwnerThread(Thread.currentThread());</span><br><span class="line">        else</span><br><span class="line">        //如果没有修改成功，表示当前存在竞争，则去走另外的逻辑</span><br><span class="line">            acquire(1);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    protected final boolean tryAcquire(int acquires) &#123;</span><br><span class="line">        return nonfairTryAcquire(acquires);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>acquire是AQS里面实现的方法，具体的方法又会在Sync的子类里面去重写，这里挺绕的</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Acquires in exclusive mode, ignoring interrupts.  Implemented</span><br><span class="line"> * by invoking at least once &#123;@link #tryAcquire&#125;,</span><br><span class="line"> * returning on success.  Otherwise the thread is queued, possibly</span><br><span class="line"> * repeatedly blocking and unblocking, invoking &#123;@link</span><br><span class="line"> * #tryAcquire&#125; until success.  This method can be used</span><br><span class="line"> * to implement method &#123;@link Lock#lock&#125;.</span><br><span class="line"> * 这方法可以理解为去尝试获取锁，如果获取不成功，则在AQS队列的尾部添加一个节点</span><br><span class="line"> *</span><br><span class="line"> * @param arg the acquire argument.  This value is conveyed to</span><br><span class="line"> *        &#123;@link #tryAcquire&#125; but is otherwise uninterpreted and</span><br><span class="line"> *        can represent anything you like.</span><br><span class="line"> */</span><br><span class="line">public final void acquire(int arg) &#123;</span><br><span class="line">    if (!tryAcquire(arg) &amp;&amp;</span><br><span class="line">        acquireQueued(addWaiter(Node.EXCLUSIVE), arg))</span><br><span class="line">        selfInterrupt();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>tryAcquire方法就是在Sync子类里面重写的</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">//尝试获取锁</span><br><span class="line">protected final boolean tryAcquire(int acquires) &#123;</span><br><span class="line">    return nonfairTryAcquire(acquires);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">        /**</span><br><span class="line">         * Performs non-fair tryLock.  tryAcquire is implemented in</span><br><span class="line">         * subclasses, but both need nonfair try for trylock method.</span><br><span class="line">         */</span><br><span class="line">        final boolean nonfairTryAcquire(int acquires) &#123;</span><br><span class="line">        //得到当前线程</span><br><span class="line">            final Thread current = Thread.currentThread();</span><br><span class="line">            //获取状态</span><br><span class="line">            int c = getState();</span><br><span class="line">            //如果为0,则表示没有锁，直接获取锁</span><br><span class="line">            if (c == 0) &#123;</span><br><span class="line">            //CAS修改state的状态，将0改成1</span><br><span class="line">                if (compareAndSetState(0, acquires)) &#123;</span><br><span class="line">                //设置线程</span><br><span class="line">                    setExclusiveOwnerThread(current);</span><br><span class="line">                    //返回true,表示获取锁成功</span><br><span class="line">                    return true;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            //因为这个是可重入锁，如果在被锁住的情况下，是不是当前线程又重新获取了一次</span><br><span class="line">            else if (current == getExclusiveOwnerThread()) &#123;</span><br><span class="line">            //如果这个锁重入了，则需要将state的值+1，来表示被同一个线程重入了多少次</span><br><span class="line">            //后续，在解锁操作时，需要依次 -1 直到state的值为0，才表示锁释放</span><br><span class="line">                int nextc = c + acquires;</span><br><span class="line">                if (nextc &lt; 0) // overflow</span><br><span class="line">                    throw new Error(&quot;Maximum lock count exceeded&quot;);</span><br><span class="line">                setState(nextc);</span><br><span class="line">                return true;</span><br><span class="line">            &#125;</span><br><span class="line">            //return false 表示锁没有获取成功</span><br><span class="line">            return false;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * Creates and enqueues node for current thread and given mode.</span><br><span class="line">     * tryAcquire这个方法没有成功获取锁，就会将当前线程封装成一个Node,添加到AQS队列的尾部</span><br><span class="line">     * @param mode Node.EXCLUSIVE for exclusive, Node.SHARED for shared</span><br><span class="line">     * @return the new node</span><br><span class="line">     */</span><br><span class="line">    private Node addWaiter(Node mode) &#123;</span><br><span class="line">    // new 一个Node节点，将当前线程放进去</span><br><span class="line">        Node node = new Node(Thread.currentThread(), mode);</span><br><span class="line">        // Try the fast path of enq; backup to full enq on failure</span><br><span class="line">        Node pred = tail;</span><br><span class="line">        //如果尾节点不等于空，表示队列里面存在其他等待的线程</span><br><span class="line">        if (pred != null) &#123;</span><br><span class="line">        // 将尾节点指向当前节点的上一个，表示把当前需要排队的节点添加到尾节点的后面</span><br><span class="line">            node.prev = pred;</span><br><span class="line">            // 用CAS替换掉尾节点，将当前节点放在尾节点的位置上</span><br><span class="line">            if (compareAndSetTail(pred, node)) &#123;</span><br><span class="line">            //然后将尾节点的next指向当前节点，就形成了一个链式</span><br><span class="line">                pred.next = node;</span><br><span class="line">                return node;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        enq(node);//如果tail为空，或者cas失败，则用自旋将节点插入到队列尾部</span><br><span class="line">        return node;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">        /**</span><br><span class="line">     * Inserts node into queue, initializing if necessary. See picture above.</span><br><span class="line">     * 将节点插入到队列尾部，必要的时候初始化</span><br><span class="line">     * @param node the node to insert</span><br><span class="line">     * @return node&apos;s predecessor</span><br><span class="line">     */</span><br><span class="line">    private Node enq(final Node node) &#123;</span><br><span class="line">    //自旋</span><br><span class="line">        for (;;) &#123;</span><br><span class="line">        // 获取尾节点，如果尾节点为null,则表示是第一次添加到队列</span><br><span class="line">            Node t = tail;</span><br><span class="line">            if (t == null) &#123; // Must initialize 必须初始化</span><br><span class="line">            // new 一个节点放到Head节点去</span><br><span class="line">                if (compareAndSetHead(new Node()))</span><br><span class="line">                //将头结点赋值给尾结点</span><br><span class="line">                    tail = head;</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">            // 如果不是第一次添加，则将当前节前添加到最后</span><br><span class="line">                node.prev = t;</span><br><span class="line">                //将当前节点设置到最后</span><br><span class="line">                if (compareAndSetTail(t, node)) &#123;</span><br><span class="line">                //将原尾节点的下一个节点指向当前节点，</span><br><span class="line">                    t.next = node;</span><br><span class="line">                    // 返回尾节点</span><br><span class="line">                    return t;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">     /**</span><br><span class="line">     * Acquires in exclusive uninterruptible mode for thread already in</span><br><span class="line">     * queue. Used by condition wait methods as well as acquire.</span><br><span class="line">     * 用于队列中的线程自旋的以独占且不可中断的方式获取同步状态</span><br><span class="line">     * @param node the node</span><br><span class="line">     * @param arg the acquire argument</span><br><span class="line">     * @return &#123;@code true&#125; if interrupted while waiting</span><br><span class="line">     */</span><br><span class="line">    final boolean acquireQueued(final Node node, int arg) &#123;</span><br><span class="line">        boolean failed = true;</span><br><span class="line">        try &#123;</span><br><span class="line">            boolean interrupted = false;</span><br><span class="line">            for (;;) &#123;</span><br><span class="line">            // 获取上一个节点</span><br><span class="line">                final Node p = node.predecessor();</span><br><span class="line">                //只有上一个节点为头节点时，才能参与锁的竞争</span><br><span class="line">                if (p == head &amp;&amp; tryAcquire(arg)) &#123;</span><br><span class="line">                // 如果竞争成功，则设置头结点</span><br><span class="line">                // 头结点不需要保存线程信息，和上一个节点的信息，所以设置为null</span><br><span class="line">                    setHead(node);</span><br><span class="line">                    // 将原头结点的的next设置为null，相当于孤立原头节点，帮助GC</span><br><span class="line">                    p.next = null; // help GC</span><br><span class="line">                    failed = false;</span><br><span class="line">                    return interrupted;</span><br><span class="line">                &#125;</span><br><span class="line">                // 判断线程的是否应该阻塞，如果是，则安全阻塞，进入到parkAndCheckInterrupt（）</span><br><span class="line">                // 方法则将线程挂起</span><br><span class="line">                if (shouldParkAfterFailedAcquire(p, node) &amp;&amp;</span><br><span class="line">                    parkAndCheckInterrupt())</span><br><span class="line">                    interrupted = true;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; finally &#123;</span><br><span class="line">            if (failed) //如果抛出异常，则取消锁的获取，进行出队操作</span><br><span class="line">                cancelAcquire(node);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h5 id="非公平锁加锁的过程描述"><a href="#非公平锁加锁的过程描述" class="headerlink" title="非公平锁加锁的过程描述"></a>非公平锁加锁的过程描述</h5><p>1、通过compareAndSetState（）去尝试更改锁的状态，如果锁状态更改成功，则表示获取锁成功，然后将当前线程保存到AbstractOwnableSynchronizer 当前的同步器</p><p>2、如果1 不成功过，就去走锁竞争的逻辑，首先会去尝试获取锁，如果获取成功 （两种可能  上一条线程执行完了，是重入了，state+1）就直接返回了</p><p>3、如果2不成功，就会先去构建一个包含当前线程信息的节点，然后插入到队列尾部，然后当前线程的上一个节点是头节点，则去尝试获取锁，如果不是，则挂起当前线程，等待解锁操作的唤醒</p><p>做了一个流程图可以参考：</p><p><img src="/ReentrantLock源码浅谈/加锁流程图.png" alt></p><p>这里面涉及到几个状态的值：</p><table><thead><tr><th>状态</th><th>值</th><th>说明</th></tr></thead><tbody><tr><td>CANCELLED</td><td>1</td><td>等待超时或者中断，需要从同步队列中取消</td></tr><tr><td>SIGNAL</td><td>-1</td><td>后继节点出于等待状态，当前节点释放锁后将会唤醒后继节点</td></tr><tr><td>CONDITION</td><td>-2</td><td>节点在等待队列中，节点线程等待在Condition上，其它线程对Condition调用signal()方法后，该节点将会从等待同步队列中移到同步队列中，然后等待获取锁。</td></tr><tr><td>PROPAGATE</td><td>-3</td><td>表示下一次共享式同步状态获取将会无条件地传播下去</td></tr><tr><td>INITIAL</td><td>0</td><td>初始状态</td></tr></tbody></table><p>加锁的过程就这些了，可以一句话总结一下，就是加锁，如果加锁失败，则放到AQS队列尾部，这个是重入锁，可以被同一个线程加锁多次，只需要在状态上+1 解锁也需将状态减少到0</p><h5 id="公平锁的加锁"><a href="#公平锁的加锁" class="headerlink" title="公平锁的加锁"></a>公平锁的加锁</h5><p>公平锁和非公平锁在上文说过了，在代码上的区别不是很多，只是在尝试获取锁之前，需要判断当前线程是CLH等待队列的表头时，才获取锁，非公平锁就是只要锁处于空闲状态，不管CLH里面的队列，就直接获取，如果获取失败，就还是相当于一个公平锁放到CLH队列里面等待</p><p>公平锁在尝试获取锁的的时候多了一个hasQueuedPredecessors()方法，如果当线程状态为0的时候，表示当前线程是空闲的，就判断当前线程是不是在等待队列的头部，如果是，则获取锁，如果不是，则和非公平锁一样，放到等待队列去</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line">         * Fair version of tryAcquire.  Don&apos;t grant access unless</span><br><span class="line">         * recursive call or no waiters or is first.</span><br><span class="line">         * 尝试获取锁</span><br><span class="line">         */</span><br><span class="line">        protected final boolean tryAcquire(int acquires) &#123;</span><br><span class="line">            final Thread current = Thread.currentThread();</span><br><span class="line">            int c = getState();</span><br><span class="line">            if (c == 0) &#123;</span><br><span class="line">                if (!hasQueuedPredecessors() &amp;&amp;</span><br><span class="line">                    compareAndSetState(0, acquires)) &#123;</span><br><span class="line">                    setExclusiveOwnerThread(current);</span><br><span class="line">                    return true;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            else if (current == getExclusiveOwnerThread()) &#123;</span><br><span class="line">                int nextc = c + acquires;</span><br><span class="line">                if (nextc &lt; 0)</span><br><span class="line">                    throw new Error(&quot;Maximum lock count exceeded&quot;);</span><br><span class="line">                setState(nextc);</span><br><span class="line">                return true;</span><br><span class="line">            &#125;</span><br><span class="line">            return false;</span><br><span class="line">        &#125;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    //判断当前线程是不是头结点的下一个节点，如果返回true,表示前面有线程在排队，如果返回false,表示没有线程在排队，可是直接获取</span><br><span class="line">public final boolean hasQueuedPredecessors() &#123;</span><br><span class="line">        // The correctness of this depends on head being initialized</span><br><span class="line">        // before tail and on head.next being accurate if the current</span><br><span class="line">        // thread is first in queue.</span><br><span class="line">        Node t = tail; // Read fields in reverse initialization order</span><br><span class="line">        Node h = head;</span><br><span class="line">        Node s;</span><br><span class="line">        return h != t &amp;&amp;</span><br><span class="line">            ((s = h.next) == null || s.thread != Thread.currentThread());</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h4 id="解锁"><a href="#解锁" class="headerlink" title="解锁"></a>解锁</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line">     * Attempts to release this lock.</span><br><span class="line">     *</span><br><span class="line">     * &lt;p&gt;If the current thread is the holder of this lock then the hold</span><br><span class="line">     * count is decremented.  If the hold count is now zero then the lock</span><br><span class="line">     * is released.  If the current thread is not the holder of this</span><br><span class="line">     * lock then &#123;@link IllegalMonitorStateException&#125; is thrown.</span><br><span class="line">     * 解锁</span><br><span class="line">     * @throws IllegalMonitorStateException if the current thread does not</span><br><span class="line">     *         hold this lock</span><br><span class="line">     */</span><br><span class="line">    public void unlock() &#123;</span><br><span class="line">        sync.release(1);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    //解锁</span><br><span class="line">    public final boolean release(int arg) &#123;</span><br><span class="line">    // 如果状态==0，就返回true,然后去唤醒</span><br><span class="line">        if (tryRelease(arg)) &#123;</span><br><span class="line">            Node h = head;</span><br><span class="line">            if (h != null &amp;&amp; h.waitStatus != 0)</span><br><span class="line">            // 将头结点的下一个节点激活</span><br><span class="line">                unparkSuccessor(h);</span><br><span class="line">            return true;</span><br><span class="line">        &#125;</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">            protected final boolean tryRelease(int releases) &#123;</span><br><span class="line">            int c = getState() - releases;</span><br><span class="line">            if (Thread.currentThread() != getExclusiveOwnerThread())</span><br><span class="line">                throw new IllegalMonitorStateException();</span><br><span class="line">            boolean free = false;</span><br><span class="line">            // 状态==0 将当前执行的线程设置为null</span><br><span class="line">            if (c == 0) &#123;</span><br><span class="line">                free = true;</span><br><span class="line">                setExclusiveOwnerThread(null);</span><br><span class="line">            &#125;</span><br><span class="line">            //设置状态</span><br><span class="line">            setState(c);</span><br><span class="line">            return free;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">      // 将头节点的下一个节点激活</span><br><span class="line">      private void unparkSuccessor(Node node) &#123;</span><br><span class="line">        /*</span><br><span class="line">         * If status is negative (i.e., possibly needing signal) try</span><br><span class="line">         * to clear in anticipation of signalling.  It is OK if this</span><br><span class="line">         * fails or if status is changed by waiting thread.</span><br><span class="line">         */</span><br><span class="line">        int ws = node.waitStatus;</span><br><span class="line">        if (ws &lt; 0)</span><br><span class="line">            compareAndSetWaitStatus(node, ws, 0);</span><br><span class="line"></span><br><span class="line">        /*</span><br><span class="line">         * Thread to unpark is held in successor, which is normally</span><br><span class="line">         * just the next node.  But if cancelled or apparently null,</span><br><span class="line">         * traverse backwards from tail to find the actual</span><br><span class="line">         * non-cancelled successor.</span><br><span class="line">         */</span><br><span class="line">        Node s = node.next;</span><br><span class="line">        if (s == null || s.waitStatus &gt; 0) &#123;</span><br><span class="line">            s = null;</span><br><span class="line">            for (Node t = tail; t != null &amp;&amp; t != node; t = t.prev)</span><br><span class="line">                if (t.waitStatus &lt;= 0)</span><br><span class="line">                    s = t;</span><br><span class="line">        &#125;</span><br><span class="line">        if (s != null)</span><br><span class="line">            LockSupport.unpark(s.thread);</span><br></pre></td></tr></table></figure><h5 id="非公平锁解锁的过程描述"><a href="#非公平锁解锁的过程描述" class="headerlink" title="非公平锁解锁的过程描述"></a>非公平锁解锁的过程描述</h5><p>解锁，将state的值-1 如果为0，则去解锁，并且将当前保存的线程信息设置为null，解锁分为两个步骤</p><p>1、将state的值 -1 如果为0，就表示能直接解锁</p><p>2、开始解锁，解锁分为两步，第一步是将头节点的状态改成0，然后将头结点的next后置节点激活</p><p>流程图:</p><p><img src="/ReentrantLock源码浅谈/解锁流程图.png" alt></p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>ReentrantLock是一个可重入锁，他的可重入是标识当前线程能在状态上+1来保证当前线程能进入已经被当前线程加锁的线程，这个源码的重点还是AbstractQueuedSynchronizer里面的这个AQS队列</p>]]></content>
      
      
      <categories>
          
          <category> 并发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JAVA </tag>
            
            <tag> 源码 </tag>
            
            <tag> 锁 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>rabbitmq小记</title>
      <link href="/rabbitmq%E5%B0%8F%E8%AE%B0.html"/>
      <url>/rabbitmq%E5%B0%8F%E8%AE%B0.html</url>
      
        <content type="html"><![CDATA[<h4 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h4><p>​    前段时间使用RabbitMQ做了一个小需求，也是一个很奇葩的需求，批量刷新一个表的外键ID,本来这个需求可以直接代码一步到位的，但是组里大佬多想了一些，考虑到了数据一致性，在事物执行的同时，避免同步方案将其他的订单商品同时同步过来，从而导致有部分订单和商品的外键没有修改成药店的主键，从而考虑使用RabbitMQ来异步的重新开一个事物去修改订单和商品的外键。</p><p>​        所以，在这里使用RabbitMQ并不是为了<strong>解耦</strong>，也不是为了<strong>削峰</strong>，而是为了我也不知道为什么，反正就是另开了一个事物</p><h4 id="开始"><a href="#开始" class="headerlink" title="开始"></a>开始</h4><p>​    这是我第一次接触消息中间件，之前间接的使用过消息中间件，在使用DataX数据同步工具的时候，算是间接的使用了，DataX会将需要取的数据放到RabbitMQ里面，然后在从RabbitMQ里面把数据拉下来。去操作这些数据，不管你是从MySql拉下来，放到oracle，还是从别人服务器的MySql拉下来放到我们自己的MySql都行，这就起到了一个解耦的作用。</p><p>​    这次算是正式的接触了RabbitMQ，但是由于当时写需求的时候有时间限制，囫囵吞枣的把代码写完了，并没有过多的了解，加上公司架构组还针对RabbitMQ上面封装了一层，因此在不使用项目框架的时候，要让程序正常运行，需要做的改动还是挺多的，所以依旧老规矩，重写一个demo,让他正常跑起来</p><h4 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h4><p>​    其实不会做什么介绍啊，理论的东西，不是很适合大龄程序员的，要什么理论，拿起键盘就干，但是这样容易吃亏的，所以这里还是学着说一说</p><p>​    RabbitMQ是一个由erlang开发的AMQP（Advanced Message Queuing Protocol）的开源实现，MQ的全程是Message Queue，翻译过来就是消息队列的意思</p><p>​    RabbitMQ是有三个端，生产者，消费者，和RabbitMQ本身，生产者负责生产数据到服务端，也就是到RabbitMQ上去，消费端就是RabbitMQ会推送数据到消费端，其中会有几个推的模式，后面慢慢道来</p><p>​    <strong>几个重要概念</strong></p><p>Exchange:消息交换机，他指定每个消息按什么规则投递到哪个队列里面</p><p>Queue:队列，也就是消息的载体，每个消息都会投到一个或多个队列中</p><p>Binding:绑定，他是将Exchange和Queue按照路由的规则绑定起来</p><p>Routing Key:路由关键字，exchange根据这个关键字进行消息投递</p><p>Producer:消息生产者，就是上文说到的负责生产数据到服务端的</p><p>Consumer:消息消费者，就是RabbitMQ会推送到订阅了该列队的消费端</p><p>Channel:消息通道，在客户端的每个链接里面可以建立多个Channel，但是本文这没有直接用到。</p><p><strong>几个交换机</strong></p><h6 id="direct交换器"><a href="#direct交换器" class="headerlink" title="direct交换器"></a>direct交换器</h6><p>这个是默认交换器，下文的例子就是使用的默认交换器</p><p>他是根据路由建去匹配的，消息会投递到绑定了相应的路由的队列上，我在网上盗了几张图，帮助自己理解</p><p><img src="/rabbitmq小记/rabbitmq-direct.png" alt></p><h6 id="Topic交换器"><a href="#Topic交换器" class="headerlink" title="Topic交换器"></a>Topic交换器</h6><p>这个交换器是根据路由键的某种通配符去匹配发送，可以使用 <em> 和 # 去匹配 </em> 表示分段 #表示0或多个字符</p><p>比如路由键的名字是 com.routingkey.test 如果我要去匹配，就可以去使用#.test 或者com.routingkey.*</p><p>这样做可以灵活的订阅自己的想要的信息，也可以按照这个规则去发布订阅这个消息</p><h6 id="fanout交换器"><a href="#fanout交换器" class="headerlink" title="fanout交换器"></a>fanout交换器</h6><p>这个就是发布订阅模式的交换器，当发送成功一条消息时，会广播到所有绑定了这个交换器的队列上。</p><p>这里有一个原来在ERP做过的场景，但是当时没有用消息队列来处理，简单说一下，当用户下单之后，系统会生成采购订单，然后会有一系列的订单流转，但是当在生成采购订单的时候，不紧紧只是生成了一些采购出库单，而是会生成其他平台的采购入库单，或者销售出库单（不同场景下的出库，所生成的订单有区别）如果按照这个交换器的模式去做的话，生成一条采购订单之后，发送一条消息，需要生成采购出库，订阅此消息即可，如果当时会生成其他更多的单据，只用在订阅该消息，这样就有了解耦，添加新需求的成本大大降低</p><h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><p>废话不多说了，看代码吧，很早之前写的一个，由于工作原因，这篇文章搁置下来了，现在继续补充完成</p><p>配置账号密码，这个简单就不用说了，是写在配置文件里面，只用读一下就好了</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * @author CongZ</span><br><span class="line"> * @classname MqConfig</span><br><span class="line"> * @create 2019/6/4</span><br><span class="line"> **/</span><br><span class="line">@ConfigurationProperties(prefix = &quot;demo.mq.changemerchantid.event.rabbitmq&quot;)</span><br><span class="line">public class MqConfig &#123;</span><br><span class="line">    private String host;</span><br><span class="line">    private int port;</span><br><span class="line">    private String username;</span><br><span class="line">    private String password;</span><br><span class="line"></span><br><span class="line">    public String getHost() &#123;</span><br><span class="line">        return host;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setHost(String host) &#123;</span><br><span class="line">        this.host = host;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public int getPort() &#123;</span><br><span class="line">        return port;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setPort(int port) &#123;</span><br><span class="line">        this.port = port;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public String getUsername() &#123;</span><br><span class="line">        return username;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setUsername(String username) &#123;</span><br><span class="line">        this.username = username;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public String getPassword() &#123;</span><br><span class="line">        return password;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setPassword(String password) &#123;</span><br><span class="line">        this.password = password;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="发送方配置"><a href="#发送方配置" class="headerlink" title="发送方配置"></a>发送方配置</h5><p>主要就是连接配置，发送的模版配置，再就是创建队列了</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> CongZ</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@classname</span> 发送方的配置</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2019/6/4</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@EnableConfigurationProperties</span>(MqConfig.class)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestAutoConfiguration</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> MqConfig mqConfig;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 简单配置，这里直接定义字符串</span></span><br><span class="line"><span class="comment">    **/</span></span><br><span class="line">    <span class="keyword">private</span> String ExchangeName=<span class="string">"changeName-test"</span>;</span><br><span class="line">    <span class="keyword">private</span> String RoutingKey=<span class="string">"RoutingKey-test"</span>;</span><br><span class="line">    <span class="keyword">private</span> String QueueName=<span class="string">"QueueName-test-2019-06-04"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">TestAutoConfiguration</span><span class="params">(MqConfig mqConfig)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.mqConfig = mqConfig;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/***</span></span><br><span class="line"><span class="comment">     * 连接配置</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ConnectionFactory <span class="title">connectionFactory</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        CachingConnectionFactory connectionFactory = <span class="keyword">new</span> CachingConnectionFactory();</span><br><span class="line">        connectionFactory.setHost(mqConfig.getHost());</span><br><span class="line">        connectionFactory.setPort(mqConfig.getPort());</span><br><span class="line">        connectionFactory.setUsername(mqConfig.getUsername());</span><br><span class="line">        connectionFactory.setPassword(mqConfig.getPassword());</span><br><span class="line">        <span class="keyword">return</span> connectionFactory;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/***</span></span><br><span class="line"><span class="comment">     * 命令发送模版</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> RabbitTemplate <span class="title">TestRabbitTemplate</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        RabbitTemplate rabbitTemplate = <span class="keyword">new</span> RabbitTemplate(connectionFactory());</span><br><span class="line">        checkAndInitQueue(connectionFactory());</span><br><span class="line">        <span class="comment">//设置JSON转换器</span></span><br><span class="line">        rabbitTemplate.setMessageConverter(<span class="keyword">new</span> Jackson2JsonMessageConverter());</span><br><span class="line">        <span class="comment">//设置交换器</span></span><br><span class="line">        rabbitTemplate.setExchange(ExchangeName);</span><br><span class="line">        <span class="comment">//设置路由key</span></span><br><span class="line">        rabbitTemplate.setRoutingKey(RoutingKey);</span><br><span class="line">        <span class="comment">//设置队列名</span></span><br><span class="line">        rabbitTemplate.setQueue(QueueName);</span><br><span class="line">        <span class="keyword">return</span> rabbitTemplate;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span>(name = <span class="string">"testService"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> TestService <span class="title">TestCommandService</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        TestService commandService = <span class="keyword">new</span> TestService(TestRabbitTemplate());</span><br><span class="line">        <span class="keyword">return</span> commandService;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/***</span></span><br><span class="line"><span class="comment">     * 初始化队列</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> connectionFactory</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">checkAndInitQueue</span><span class="params">(ConnectionFactory connectionFactory)</span></span>&#123;</span><br><span class="line">        RabbitAdmin admin = <span class="keyword">new</span> RabbitAdmin(connectionFactory);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 创建交换器</span></span><br><span class="line"><span class="comment">         * 这里有四种交换器的类型</span></span><br><span class="line"><span class="comment">         * DirectExchange 默认交换器 由路由去匹配</span></span><br><span class="line"><span class="comment">         * TopicExchange 根据路由key和某模式去匹配，广播的升级版</span></span><br><span class="line"><span class="comment">         * FanoutExchange 广播,即发送消息到Exchange,所有的Queue都能接收到消息，然后由消费者消费</span></span><br><span class="line"><span class="comment">         * HeadersExchange 不去会匹配路由key和绑定的key，会去匹配消息里面的消息头去匹配q</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        admin.declareExchange(<span class="keyword">new</span> DirectExchange(ExchangeName));</span><br><span class="line">        Map&lt;String, Object&gt; args = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 定义队列</span></span><br><span class="line"><span class="comment">         * 参数1：队列名</span></span><br><span class="line"><span class="comment">         * 参数2：是否持久化 因为队列是放在内存里面，</span></span><br><span class="line"><span class="comment">         *       当rabbitmq重启会丢失，设置为True,消息会保存到Erlang自带的Mnesia数据库中</span></span><br><span class="line"><span class="comment">         *       rabbitmq重启就回读取数据库</span></span><br><span class="line"><span class="comment">         * 参数3：是否独占</span></span><br><span class="line"><span class="comment">         *       如果独占，则会给当前队列加锁，其他消费者是不能访问，一般设置为false</span></span><br><span class="line"><span class="comment">         *       如果为true,则一个队列只能有一个消费者消费</span></span><br><span class="line"><span class="comment">         * 参数4：是否自动删除，当最后一个消费者断开之后</span></span><br><span class="line"><span class="comment">         *       队列是否会被自动删除 在RabbitMq Management中consumers=0时队列就会自动删除</span></span><br><span class="line"><span class="comment">         * 参数5：其他参数</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        admin.declareQueue(<span class="keyword">new</span> Queue(QueueName, <span class="keyword">true</span>, <span class="keyword">false</span>, <span class="keyword">false</span>, args));</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 绑定队列</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        admin.declareBinding(<span class="keyword">new</span> Binding(QueueName, Binding.DestinationType.QUEUE, ExchangeName, RoutingKey, <span class="keyword">null</span>));</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * @author CongZ</span><br><span class="line"> * @classname 发送的类，这里我们一般在写项目的时候会单独抽出来</span><br><span class="line"> * @create 2019/6/5</span><br><span class="line"> **/</span><br><span class="line">public class TestService &#123;</span><br><span class="line"></span><br><span class="line">    private final RabbitTemplate template;</span><br><span class="line"></span><br><span class="line">    public TestService(RabbitTemplate template)&#123;</span><br><span class="line">        this.template = template;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public boolean send(String str) &#123;</span><br><span class="line">        template.convertAndSend(str);</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="消费方配置"><a href="#消费方配置" class="headerlink" title="消费方配置"></a>消费方配置</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * @author CongZ</span><br><span class="line"> * @classname 消费端配置</span><br><span class="line"> * @create 2019/6/5</span><br><span class="line"> **/</span><br><span class="line"></span><br><span class="line">@Configuration</span><br><span class="line">@EnableConfigurationProperties(MqConfig.class)</span><br><span class="line">public class TestContainer &#123;</span><br><span class="line"></span><br><span class="line">    private final MqConfig mqConfig;</span><br><span class="line"></span><br><span class="line">    @Autowired</span><br><span class="line">    public TestContainer(MqConfig mqConfig) &#123;</span><br><span class="line">        this.mqConfig = mqConfig;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public ConnectionFactory connectionFactory() &#123;</span><br><span class="line">        CachingConnectionFactory connectionFactory = new CachingConnectionFactory();</span><br><span class="line">        connectionFactory.setHost(mqConfig.getHost());</span><br><span class="line">        connectionFactory.setPort(mqConfig.getPort());</span><br><span class="line">        connectionFactory.setUsername(mqConfig.getUsername());</span><br><span class="line">        connectionFactory.setPassword(mqConfig.getPassword());</span><br><span class="line">        return connectionFactory;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Bean(name = &quot;singleListenerContainer&quot;)</span><br><span class="line">    public SimpleRabbitListenerContainerFactory listenerContainer()&#123;</span><br><span class="line">        SimpleRabbitListenerContainerFactory factory = new SimpleRabbitListenerContainerFactory();</span><br><span class="line">        //设置连接</span><br><span class="line">        factory.setConnectionFactory(connectionFactory());</span><br><span class="line">        //设置消息序列化类型</span><br><span class="line">        factory.setMessageConverter(new Jackson2JsonMessageConverter());</span><br><span class="line">        //设置每个MessageListenerContainer将会创建的Consumer的最小数量，默认是1个。</span><br><span class="line">        factory.setConcurrentConsumers(1);</span><br><span class="line">        //设置最大的</span><br><span class="line">        factory.setMaxConcurrentConsumers(1);</span><br><span class="line">        //设置每次请求发送给每个Consumer的消息数量。</span><br><span class="line">        factory.setPrefetchCount(1);</span><br><span class="line">        //设置事务当中可以处理的消息数量。</span><br><span class="line">        factory.setTxSize(1);</span><br><span class="line"></span><br><span class="line">        //factory.setErrorHandler(); //设置处理失败的处理类</span><br><span class="line">        /***</span><br><span class="line">         * 设置消费端的应答模式</span><br><span class="line">         *</span><br><span class="line">         */</span><br><span class="line">        factory.setAcknowledgeMode(AcknowledgeMode.MANUAL);</span><br><span class="line">        return factory;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="消费的类"><a href="#消费的类" class="headerlink" title="消费的类"></a>消费的类</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * @author CongZ</span><br><span class="line"> * @classname TestHandler</span><br><span class="line"> * @create 2019/6/12</span><br><span class="line"> **/</span><br><span class="line">@Component</span><br><span class="line">public class TestHandler &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">//    @RabbitListener(bindings = @QueueBinding(</span><br><span class="line">//            value = @Queue(value = TopicRabbitConfig.QUEUE_NAME, durable = &quot;true&quot;),</span><br><span class="line">//            exchange = @Exchange(value = TopicRabbitConfig.TEST_EXCHANGE_HAHA, type = ExchangeTypes.TOPIC),</span><br><span class="line">//            key = TopicRabbitConfig.TEST_TOPIC_ROUTINGKEY)</span><br><span class="line">//    )</span><br><span class="line">    @RabbitListener(queues=&quot;QueueName-test-2019-06-04&quot;,containerFactory =&quot;singleListenerContainer&quot;)</span><br><span class="line">    public void handler(Message message, Channel channel) throws IOException &#123;</span><br><span class="line">        System.out.println(&quot;监听消费端的消息：&quot;+new String(message.getBody()));</span><br><span class="line">        try&#123;</span><br><span class="line">//            String is=null;</span><br><span class="line">//            is.toString();</span><br><span class="line"></span><br><span class="line">            /***</span><br><span class="line">             * false表示 只确认当前的消费者收到一个消息，true 表示确认所有的消费者获得消息</span><br><span class="line">             */</span><br><span class="line">            channel.basicAck(message.getMessageProperties().getDeliveryTag(),false);</span><br><span class="line">        &#125;catch(Exception ex)&#123;</span><br><span class="line">            System.out.println(&quot;消息处理失败，重新丢到队列去&quot;);</span><br><span class="line">            /***</span><br><span class="line">             * multiple false 只拒绝当前标签提供的消息，true表示拒绝所有的消息</span><br><span class="line">             * requeue false 表示直接丢掉，true表示重新入队</span><br><span class="line">             */</span><br><span class="line">            channel.basicNack(message.getMessageProperties().getDeliveryTag(),false,true);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="讲一下"><a href="#讲一下" class="headerlink" title="讲一下"></a>讲一下</h4><p>上述的内容都挺简单的，是按照公司的配置做一些改版，搭建出来，spring boot更方便的搭建方式，比我的更通俗易懂，但是这个更方便让自己知道始末。</p><p>这篇文章只是开始，后面打算研究rabbitmq的重试机制，使用死信队列，以及延时加载。上文的例子，是使用的手动确认方式，当消费失败，则该消息会重新放到队列，继续消费，这样会导致一个问题，会频繁重复加载，则会对后面的消息造成阻塞，。</p><p>一般在项目中会使用自动确认的模式，即不报错就会自动消费。但是在复杂情况下也会有例外</p><h4 id="记一下"><a href="#记一下" class="headerlink" title="记一下"></a>记一下</h4><p>[]: <a href="https://www.cnblogs.com/piaolingzxh/p/5448927.html" target="_blank" rel="noopener">https://www.cnblogs.com/piaolingzxh/p/5448927.html</a><br>[]: <a href="https://www.jianshu.com/p/2c5eebfd0e95" target="_blank" rel="noopener">https://www.jianshu.com/p/2c5eebfd0e95</a><br>[]: <a href="https://juejin.im/post/5a12ffd451882578da0d7b3a" target="_blank" rel="noopener">https://juejin.im/post/5a12ffd451882578da0d7b3a</a></p><p>在这做一个记录，上面三篇文章写的挺好的</p><p>介绍了关于消息确认以及延时列队的内容，下次写关于rabbitmq的内容，就去研究一下</p><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>这些内容耗时太长了，由于这段时间工作生活的一些原因，导致本来已经开篇的文章，一直搁置，最后都不知道自己要写什么，结果就是这篇文章看上去很散乱，所以尽早结束重新开篇。</p>]]></content>
      
      
      <categories>
          
          <category> 消息队列 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 消息队列，RabbitMQ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>synchronized的实现原理和应用</title>
      <link href="/synchronized%E7%9A%84%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86%E5%92%8C%E5%BA%94%E7%94%A8.html"/>
      <url>/synchronized%E7%9A%84%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86%E5%92%8C%E5%BA%94%E7%94%A8.html</url>
      
        <content type="html"><![CDATA[<h4 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h4><p>下班回来无事，电视剧没更新，吃鸡没队友，无奈打开电脑，看见旁边落灰已久的《Java并发编程的艺术》随手拿起来翻了几页，作为程序员的我感觉发现了新大陆，瞬间一发不可收拾，越看越有意思。现在想想我为什么要买这本书呢，其实从工作以来，一直就在看这方面的内容，奈何网络上知识零碎，加上理解有差，所以买回来看看，看看完整的。增加自己知识的完整度。</p><p>对于这种工具书，我的观念是千万不能看PDF和各种电子的，工具书就是要做到及时，随看随翻，可以当成字典用，需要什么翻什么，也切记从头读到尾，我的做法是，对哪方面感兴趣就去看哪，毕竟工具书没有剧情的，上下文跳着看不影响的。还有一定要记得看了之后做笔记，也就是我现在做的事，不然看了之后用不上，时间久了等于白看。好了，不多说废话了，今天看了关于标题内容的一节，记录一下，文章不长。毕竟信书不如无书，肯定看了之后加上我的理解才有了这篇文章</p><h4 id="好，开始！"><a href="#好，开始！" class="headerlink" title="好，开始！"></a>好，开始！</h4><p>说到synchronized，这个在java开发工程师眼中肯定不陌生，Hashtable和currentHashMap的源码都是有这个的，不信打开你们的idea  然后ctrl+H（我的是这个快捷键）看看你们项目中有多少用到这个方法了。</p><p>很多人都程序它为重量级锁，就是当你锁住了一个方法，或者锁住了一个方法块，则其他线程就进不来，如果当前锁的时间耗时比较长，则会影响程序性能。但是jdk 1.6对synchronized进行了优化，有些情况他就不那么重了，这里详细介绍jdk1.6为了减少获得锁和释放锁带来的性能小号而引入的偏向锁和轻量级锁以及所得存储结构和升级过程。</p><h4 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h4><h5 id="锁的3种表现形式"><a href="#锁的3种表现形式" class="headerlink" title="锁的3种表现形式"></a>锁的3种表现形式</h5><p>如果锁住了普通方法，则synchronized锁住的是当前对象（方法）</p><p>如果锁住了静态的方法，则synchronized锁住的是当前类的Class对象</p><p>如果锁住了一个方法块，及synchronized{}，则锁的是中括号里面的对象，来看看代码吧</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">//锁住的是当前方法</span><br><span class="line">public synchronized demo&#123;</span><br><span class="line">    //dosomething</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//此时锁会升级，锁住demo1这个类</span><br><span class="line">class demo1&#123;</span><br><span class="line">    public static synchronized demo&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//这个只会锁住当前&#123;&#125;里面的内容</span><br><span class="line">synchronized&#123;</span><br><span class="line">    //dosomthing</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当一个线程试图访问同步的代码块是，他必须要先得到锁，退出或抛出异常时必须释放锁</p><p>JVM规范中可以看到synchronized是基于进入和退出Monitor对象来实现方法的同步和代码块的同步，但两者的现实细节不一样，代码块同步是用的monitorenter和monitorexit指令现实的，而方法同步是用的另外一种方法，但是都可以用这两个指令来实现，这里我曾经有幸看过字节码，确实是这样的，我就不翻出来看了。</p><p>monitorenter指令时在编译后插入到同步代码块的开始位置，而monitorexit则插入在方法结束和异常的地方，JVM要保证每个monitorenter都有一个monitorexit与之配对，任何对象都有一个monitor与之关联，当一个monitor被持有之后，他就会处于锁定状态，线程执行到monitorenter指令时，将会尝试获取对象所对应的monitor所有权，即尝试获得对象锁</p><h5 id="锁的升级和对比"><a href="#锁的升级和对比" class="headerlink" title="锁的升级和对比"></a>锁的升级和对比</h5><p>书看到这里其实已经不是很懂了，本来想上网搜一下，偏向锁和轻量级锁的原理的，发现网上那些都和我这本书上的一样，哈，我想说我书买对了。</p><p>继续吧！</p><p>上文说过了，为了性能提升，引入了偏向锁和轻量级锁，锁一共有4中状态，级别从低到高分别是，无锁状态 -&gt;</p><p>偏向锁状态 -&gt; 轻量级锁状态 -&gt; 重量级锁状态，这个状态会随着锁的竞争情况去升级，而且只能升级，不能降级，就是只能从偏向锁到轻量级锁，不能从轻量级锁到偏向锁。 </p><h6 id="偏向锁"><a href="#偏向锁" class="headerlink" title="偏向锁"></a>偏向锁</h6><p>偏向锁适用于只有一个线程访问同步块的场景</p><p>HotSpot的作者研究发现大多数情况下，锁不仅不存在多线程竞争，而且总是由同一个线程多次获得，所以为了减少线程获得锁的代价，则引入了偏向锁。当一个线程访问同步块的代码的时候，会在对象头和栈帧中存入这个线程的ID,就相当于是做一个标记，如果下次该线程在来获取这个锁的时候，就不需要进行CAS操作来加锁和解锁了，只需要简单的判断一下对象头的Mark Word里面的ID是不是和当前访问的线程ID一致，如果一致，则直接获取到锁，如果不一致，则先去判断一下Mark Word中的偏向锁的标识是否设置成了1（表示当前为偏向锁），如果没有的话，则用CAS去竞争锁，如果竞争成功了，则将对象头里面的ID改成当前线程的ID，如果失败了，就去判断线程是否处于活动状态，如果不处于活动状态，也就是表示已经执行完了同步块里面的内容。则将对象头设置成无锁状态，如果线程还活着，则要么偏向于其他线程，要么恢复到无锁或者标记对象不适合作为偏向锁，然后唤醒暂停的线程，下面看书里面的一张图应该就好理解的，我倒现在应该看懂了。</p><p><img src="/synchronized的实现原理和应用/1.png" alt></p><h6 id="轻量级锁"><a href="#轻量级锁" class="headerlink" title="轻量级锁"></a>轻量级锁</h6><p>看了一下书，也在网上找了资料，我的理解是偏向锁和轻量级锁的区别是偏向锁省略了CAS的操作，轻量级锁在竞争锁的时候，会尝试使用自旋来获取锁，当自旋获取锁失败之后，则轻量级锁会膨胀成重量级锁。因为自旋会消耗CPU,为了避免无用的自旋（阻塞时），一旦锁升级到了重量级锁，则就不会在恢复到轻量级锁了，上文也说过了，只会升级，不会降级，当升级到重量级锁时，其他线程只能等待当前线程执行完，释放锁之后才会唤醒其他线程。还是有个图，看看吧</p><p><img src="/synchronized的实现原理和应用/2.png" alt></p><h5 id="锁的优缺点对比"><a href="#锁的优缺点对比" class="headerlink" title="锁的优缺点对比"></a>锁的优缺点对比</h5><table><thead><tr><th><strong>锁</strong></th><th><strong>优点</strong></th><th><strong>缺点</strong></th><th><strong>使用场景</strong></th></tr></thead><tbody><tr><td>偏向锁</td><td>加锁和解锁不需要CAS操作，没有额外的性能消耗，和执行非同步方法相比仅存在纳秒级的差距</td><td>如果线程间存在锁竞争，会带来额外的锁撤销的消耗</td><td>适用于只有一个线程访问同步快的场景</td></tr><tr><td>轻量级锁</td><td>竞争的线程不会阻塞，提高了响应速度</td><td>如线程成始终得不到锁竞争的线程，使用自旋会消耗CPU性能</td><td>追求响应时间，同步快执行速度非常快</td></tr><tr><td>重量级锁</td><td>线程竞争不适用自旋，不会消耗CPU</td><td>线程阻塞，响应时间缓慢，在多线程下，频繁的获取释放锁，会带来巨大的性能消耗</td><td>追求吞吐量，同步快执行速度较长</td></tr></tbody></table><h4 id="结尾"><a href="#结尾" class="headerlink" title="结尾"></a>结尾</h4><p>这本书里面的一小部分看完了，也弄懂了，只能说大概的弄懂了，明天去翻翻《深入理解Java虚拟机》这本书里面关于这点是怎么讲的，今天就先到这了，大致了解了一下，有时间再补充。</p>]]></content>
      
      
      <categories>
          
          <category> 并发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JAVA </tag>
            
            <tag> 并发 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ArrayList和LinkedList简单讲讲</title>
      <link href="/ArrayList%E5%92%8CLinkedList%E7%AE%80%E5%8D%95%E8%AE%B2%E8%AE%B2.html"/>
      <url>/ArrayList%E5%92%8CLinkedList%E7%AE%80%E5%8D%95%E8%AE%B2%E8%AE%B2.html</url>
      
        <content type="html"><![CDATA[<h4 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h4><p>昨天请假了，去银行签贷款去了，然后和女朋友去办护照了，发生了一件事。在银行打印资金证明时，被要求买他们的一款理财产品，理由是资金少了，需要对他们的产品进行一个覆盖。我的天，现在都这样了吗。没钱没人权吗？在和银行的工作人员狡辩了几句，大致内容如下，我有自己买理财产品，也是货币基金，如果我买你们的理财，我也不会动用用于首付款的钱。心里想，毕竟找你们借钱，你是爷，抱着能少说两句就少说两句的心态，没有继续往下争辩，私下和贷款岗的工作人员联系，他们给我的解决办法是，去其他支行打印资金证明，再来交给跟我签贷款的人，在这里我就不说是哪个银行了。很气愤。好了，不多说，生活中的小事，一笑而过。</p><h4 id="开始"><a href="#开始" class="headerlink" title="开始"></a>开始</h4><p>其实这篇文章在我的有道云笔记里面是分开两篇的，很久之前写的，现在翻出来看看，有很多废话，我就索性将他们合二为一，去其糟粕取其精华。这里说一下，我有时会在宿舍或者手机简单的用有道云做一下笔记，然后就会在公司的电脑上面，去排版，添加内容，整理格式，整理语句，因为之后公司的电脑才会有Hexo+Next的环境，今天星期六，调休过来加班。带薪划水。</p><h4 id="正式开始"><a href="#正式开始" class="headerlink" title="正式开始"></a>正式开始</h4><h5 id="比较"><a href="#比较" class="headerlink" title="比较"></a>比较</h5><p>ArrayList是一个基于动态数组实现的一个数据结构，LinkdeList是基于链表的一个数据结构</p><p>ArrayList就没什么看图的，一个数组，能自动扩容，LinkedList我从网上弄来一张图，帮助理解这个数据结构</p><p>这个就是LinkedList的数据结构，可以看到，他不仅维护了数组，还维护了前后两个节点，来关联数组的先后顺序</p><p>这里我理解的是：ArrayList就是一群小朋友排队站在一起，LindedList就是一群小朋友手拉手站在一起，这样在排队的时候（插入，删除）就会很快，不需要重新排位置，只需要两边的小朋友交换一下拉手的对象就好了</p><p><img src="/ArrayList和LinkedList简单讲讲/1.png" alt></p><p>看了这个图，在来比较一下ArrayList和LinkedList的区别：</p><p>先来看看LinkedList，他相比ArrayList多维护了一个前后的两个节点，相当于利用了<strong>空间来换取时间</strong>，我们在快读删除或者插入元素的时候，就用LinkedList，在查询的时候就不应该用LinkedList了，因为LinkedList在查询的时候是需要不断的遍历，而ArrayList只需要找出下标就好了。</p><p>删除或者插入的时候LinkedList只需要动一下前后两个节点让他们重新关联上，而ArrayList需要将后面的节点往后面位移一位。</p><h5 id="不废话了，看代码吧"><a href="#不废话了，看代码吧" class="headerlink" title="不废话了，看代码吧"></a>不废话了，看代码吧</h5><h6 id="ArrayList"><a href="#ArrayList" class="headerlink" title="ArrayList"></a>ArrayList</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line">* Appends the specified element to the end of this list.</span><br><span class="line">* 将指定元素追加到列表的的尾部</span><br><span class="line">*</span><br><span class="line">* @param e element to be appended to this list</span><br><span class="line">* @return &lt;tt&gt;true&lt;/tt&gt; (as specified by &#123;@link Collection#add&#125;)</span><br><span class="line">*/</span><br><span class="line">public boolean add(E e) &#123;</span><br><span class="line">    //进行扩容效验</span><br><span class="line">    ensureCapacityInternal(size + 1); // Increments modCount!!</span><br><span class="line">    //将值放到数组的末尾，然后将size自加1</span><br><span class="line">    elementData[size++] = e;</span><br><span class="line">    return true;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">public void add(int index, E element) &#123;</span><br><span class="line">    //验证index的有效性，如果索引超出数组的范围则抛出异常IndexOutof</span><br><span class="line">    rangeCheckForAdd(index);</span><br><span class="line">    //将值放到数组的末尾，然后将size自加1</span><br><span class="line">    ensureCapacityInternal(size + 1); // Increments modCount!!</span><br><span class="line">    //copy数据，将要插入的位置空出来，将后面的元素往后移一位</span><br><span class="line">    System.arraycopy(elementData, index, elementData, index + 1,</span><br><span class="line">    size - index);</span><br><span class="line">    //将空出来的位置，插入element</span><br><span class="line">    elementData[index] = element;</span><br><span class="line">    size++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面调用最终调用的扩容代码就是下面的grow方法。每次会扩容1.5倍</p><p>int newCapacity = oldCapacity + (oldCapacity &gt;&gt; 1);</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line">* Increases the capacity to ensure that it can hold at least the</span><br><span class="line">* number of elements specified by the minimum capacity argument.</span><br><span class="line">*</span><br><span class="line">* @param minCapacity the desired minimum capacity</span><br><span class="line">*/</span><br><span class="line">private void grow(int minCapacity) &#123;</span><br><span class="line">    // overflow-conscious code</span><br><span class="line">    int oldCapacity = elementData.length;</span><br><span class="line">    int newCapacity = oldCapacity + (oldCapacity &gt;&gt; 1);</span><br><span class="line">    if (newCapacity - minCapacity &lt; 0)</span><br><span class="line">    newCapacity = minCapacity;</span><br><span class="line">    if (newCapacity - MAX_ARRAY_SIZE &gt; 0)</span><br><span class="line">    newCapacity = hugeCapacity(minCapacity);</span><br><span class="line">    // minCapacity is usually close to size, so this is a win:</span><br><span class="line">    elementData = Arrays.copyOf(elementData, newCapacity);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>数据扩容校验，如果不带构造参数时（不指定大小时）会自动生成一个长度为10的Objecr类型的数组</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line">* Default initial capacity.</span><br><span class="line">*/</span><br><span class="line">private static final int DEFAULT_CAPACITY = 10;</span><br><span class="line">private static int calculateCapacity(Object[] elementData, int minCapacity) &#123;</span><br><span class="line">    if (elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA) &#123;</span><br><span class="line">    return Math.max(DEFAULT_CAPACITY, minCapacity);</span><br><span class="line">    &#125;</span><br><span class="line">    return minCapacity;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h6 id="LinkedList"><a href="#LinkedList" class="headerlink" title="LinkedList"></a>LinkedList</h6><p>这里有两个指针，一个指向头，一个指向尾，在代码里面会用来判断是否为空啊，来区分该节点是否是最后一个节点，</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">transient int size = 0;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line">* Pointer to first node.</span><br><span class="line">//指向头节点的指针</span><br><span class="line">* Invariant: (first == null &amp;&amp; last == null) ||</span><br><span class="line">* (first.prev == null &amp;&amp; first.item != null)</span><br><span class="line">*/</span><br><span class="line">transient Node&lt;E&gt; first;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line">* Pointer to last node.</span><br><span class="line">//指向尾节点的指针</span><br><span class="line">* Invariant: (first == null &amp;&amp; last == null) ||</span><br><span class="line">* (last.next == null &amp;&amp; last.item != null)</span><br><span class="line">*/</span><br><span class="line">transient Node&lt;E&gt; last;</span><br></pre></td></tr></table></figure><p>看一下LinkedList的数据结构，这里维护了前后两个节点，上文说过了</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">//节点结构</span><br><span class="line">private static class Node&lt;E&gt; &#123;</span><br><span class="line">    E item;//数据</span><br><span class="line">    Node&lt;E&gt; next;//下一个节点（尾部）</span><br><span class="line">    Node&lt;E&gt; prev;//上一个节点（头部）</span><br><span class="line"></span><br><span class="line">    Node(Node&lt;E&gt; prev, E element, Node&lt;E&gt; next) &#123;</span><br><span class="line">        this.item = element;</span><br><span class="line">        this.next = next;</span><br><span class="line">        this.prev = prev;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里我看了一下add的方法，add之后他会将数据放在最后，就会调用linkLast(E e)这个方法</p><p>代码里面都写了注释，这里就是将元素放进去，然后设置一下前后节点的位置，其实当时理解起来挺绕的</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line">* Links e as first element.</span><br><span class="line">*/</span><br><span class="line">//设置为第一个节点</span><br><span class="line">private void linkFirst(E e) &#123;</span><br><span class="line">        //获取头节点</span><br><span class="line">    final Node&lt;E&gt; f = first;</span><br><span class="line">        //新建一个节点， 因为为双向链表，所以设置e节点为首节点时，头部为null，尾部，应该是first</span><br><span class="line">    final Node&lt;E&gt; newNode = new Node&lt;&gt;(null, e, f);</span><br><span class="line">    //将新建的节点设置成first节点。</span><br><span class="line">    first = newNode;</span><br><span class="line">    //如果首节点f没有，证明此链表为null，这个时候要设置最后一个节点也为当前节点</span><br><span class="line">    //否则将f节点的头部设置成新建的节点newNode</span><br><span class="line">    if (f == null)</span><br><span class="line">        last = newNode;</span><br><span class="line">    else</span><br><span class="line">        f.prev = newNode;</span><br><span class="line">    size++;</span><br><span class="line">    modCount++;</span><br><span class="line">&#125;</span><br><span class="line">/**</span><br><span class="line">* Links e as last element.</span><br><span class="line">*/</span><br><span class="line">//设置为最后一个节点</span><br><span class="line">void linkLast(E e) &#123;</span><br><span class="line">//获取最后一个节点</span><br><span class="line">    final Node&lt;E&gt; l = last;</span><br><span class="line">//新建一个节点，设置头部为最后一个节点L,尾部为null</span><br><span class="line">    final Node&lt;E&gt; newNode = new Node&lt;&gt;(l, e, null);</span><br><span class="line">//复制给最后一个节点</span><br><span class="line">    last = newNode;</span><br><span class="line">//如果最后一个节点为null,则将第一个节点设置为新建的节点</span><br><span class="line">//否则，将最后一个节点的尾部设置为刚才新建的节点</span><br><span class="line">    if (l == null)</span><br><span class="line">        first = newNode;</span><br><span class="line">    else</span><br><span class="line">        l.next = newNode;</span><br><span class="line">    size++;</span><br><span class="line">    modCount++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这两个方法也是在操作数据结构的时候用的比较多的，主题内容也是在做手拉手操作，不能让这个链表断了。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line">* Inserts element e before non-null Node succ.</span><br><span class="line">*/</span><br><span class="line">//将元素插入到指定的succ之前</span><br><span class="line">void linkBefore(E e, Node&lt;E&gt; succ) &#123;</span><br><span class="line">    // assert succ != null;</span><br><span class="line">//假装succ不为null</span><br><span class="line">//获取succ节点的头部</span><br><span class="line">    final Node&lt;E&gt; pred = succ.prev;</span><br><span class="line">//新建一个节点将头部设置succ的头部，尾部设置为succ,就相当于替换了succ的前面关联的数据为新建的节点，然后尾部就设置为</span><br><span class="line">//succ这个节点</span><br><span class="line">    final Node&lt;E&gt; newNode = new Node&lt;&gt;(pred, e, succ);</span><br><span class="line">//将succ的头部设置成新建的节点，则newNode就在succ之前去了</span><br><span class="line">    succ.prev = newNode;</span><br><span class="line">//如果succ没有头部，则证明succ为首节点，此时有数据插到前面来了，所以要改first</span><br><span class="line">    if (pred == null)</span><br><span class="line">        first = newNode;</span><br><span class="line">    else</span><br><span class="line">//要设置succ和前面关联的节点的下一个节点，原来pred.next是succ,现在succ前面来了一个则要改</span><br><span class="line">        pred.next = newNode;</span><br><span class="line">    size++;</span><br><span class="line">    modCount++;</span><br><span class="line">&#125;</span><br><span class="line">/**</span><br><span class="line">* Unlinks non-null first node f.</span><br><span class="line">*/</span><br><span class="line">//删除第一个首节点</span><br><span class="line">private E unlinkFirst(Node&lt;E&gt; f) &#123;</span><br><span class="line">    // assert f == first &amp;&amp; f != null;</span><br><span class="line">//假设f是第一个节点，f不等于null</span><br><span class="line">//获取f的值</span><br><span class="line">    final E element = f.item;</span><br><span class="line">//获取f的下一个节点，可以理解为第二个节点，因为f为第一个节点</span><br><span class="line">    final Node&lt;E&gt; next = f.next;</span><br><span class="line">//设置f的值为null和f的尾部为null，等待gc回收</span><br><span class="line">    f.item = null;</span><br><span class="line">    f.next = null; // help GC</span><br><span class="line">//将f的下一节点设置成首节点</span><br><span class="line">    first = next;</span><br><span class="line">//如果f的下一节点为null,证明这个链表里面只有一个元素就是f,删除之后就没了，所以设置last为null</span><br><span class="line">    if (next == null)</span><br><span class="line">        last = null;</span><br><span class="line">    else</span><br><span class="line">//如果f的下一个节点不为null,就要将下一个节点的头部，设置为null,因为删除首节点之后，第二个节点到前面，他的头部就是null</span><br><span class="line">        next.prev = null;</span><br><span class="line">    size--;</span><br><span class="line">    modCount++;</span><br><span class="line">    return element;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>indexOf</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">public int indexOf(Object o) &#123;</span><br><span class="line">    int index = 0;</span><br><span class="line">    //如果o为null</span><br><span class="line">    if (o == null) &#123;</span><br><span class="line">        for (Node&lt;E&gt; x = first; x != null; x = x.next) &#123;</span><br><span class="line">            if (x.item == null)</span><br><span class="line">            //如果item=null,返回索引</span><br><span class="line">                return index;</span><br><span class="line">            index++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        for (Node&lt;E&gt; x = first; x != null; x = x.next) &#123;</span><br><span class="line">            //判断对象o是否等于item,返回索引</span><br><span class="line">            if (o.equals(x.item))</span><br><span class="line">                return index;</span><br><span class="line">            index++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return -1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>查找节点</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">Node&lt;E&gt; node(int index) &#123;</span><br><span class="line">    // assert isElementIndex(index);</span><br><span class="line">    // 首先会判断index处于前面还是后面 size &gt;&gt; 1 把当前链表/2</span><br><span class="line">    if (index &lt; (size &gt;&gt; 1)) &#123;</span><br><span class="line">        //从前面开始遍历</span><br><span class="line">        Node&lt;E&gt; x = first;</span><br><span class="line">        for (int i = 0; i &lt; index; i++)</span><br><span class="line">            x = x.next;</span><br><span class="line">        return x;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        //从后面开始遍历</span><br><span class="line">        Node&lt;E&gt; x = last;</span><br><span class="line">        for (int i = size - 1; i &gt; index; i--)</span><br><span class="line">            x = x.prev;</span><br><span class="line">        return x;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="ArrayList扩容机制"><a href="#ArrayList扩容机制" class="headerlink" title="ArrayList扩容机制"></a>ArrayList扩容机制</h5><p>ArrayList自动增加大小的机制是：向ArrayList里面添加对象，如果当前对象的长度+1大于原数组的长度，则调用grow扩容</p><p>扩容的容量为当前数组长度的1.5倍并且复制出来一个新数组，原数组自动抛弃（java垃圾回收机制会自动回收）。</p><p>size则在向数组添加对象，自增1。</p>]]></content>
      
      
      <categories>
          
          <category> JAVA </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JAVA </tag>
            
            <tag> 集合，源码 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>自定义注解之读写分离</title>
      <link href="/%E8%87%AA%E5%AE%9A%E4%B9%89%E6%B3%A8%E8%A7%A3%E4%B9%8B%E8%AF%BB%E5%86%99%E5%88%86%E7%A6%BB.html"/>
      <url>/%E8%87%AA%E5%AE%9A%E4%B9%89%E6%B3%A8%E8%A7%A3%E4%B9%8B%E8%AF%BB%E5%86%99%E5%88%86%E7%A6%BB.html</url>
      
        <content type="html"><![CDATA[<h4 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h4><p>这段时间由于公司马上要做618的活动了，担心并发上来了，系统扛不住，所以这段时间都在做系统的优化，先开始做的是将大量的查询接口先落到从库上面去，降低主库请求次数，后面会由DBA会整理出那些慢SQL和执行次数较多的SQL，然后去优化sql和业务，这是后话了，这次主要是去给只读接口添加上自定义注解，让这些请求全部落到从库上去。闲来无事也看了一下自定义注解的实现方法，以及mybatis多数据源的实现方法。</p><h4 id="开始"><a href="#开始" class="headerlink" title="开始"></a>开始</h4><p>据说这个自定义注解和多数据源是架构组实现的，我先来探探究竟，我将这个自定义注解分离出来做成了一个小demo,可以说是呕心沥血，各种异常，各种缺bean，但最终还是能正常使用，直接看代码吧</p><h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><h5 id="注解的定义"><a href="#注解的定义" class="headerlink" title="注解的定义"></a>注解的定义</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">/***</span><br><span class="line"> * 自定义注解实现读数据源</span><br><span class="line"> * create by Congz</span><br><span class="line"> *</span><br><span class="line"> */</span><br><span class="line">@Target(&#123;ElementType.METHOD, ElementType.TYPE&#125;)</span><br><span class="line">@Retention(RetentionPolicy.RUNTIME)</span><br><span class="line">@Inherited</span><br><span class="line">@Documented</span><br><span class="line">public @interface ReadDataSource &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先定义一个注解 <strong>ReadDataSource</strong>r上面有四个元注解。</p><p>@Target({ElementType.METHOD, ElementType.TYPE})表示了这个注解的可修饰范围，我只给他指定了作用在方法上，和作用在类上</p><p>@Retention(RetentionPolicy.RUNTIME)表示这个注解的有效时间，这个注解是动态切换数据源的，所以我给的是运行时有效</p><p>@Inherited 允许子类继承父类的注解，当一个类上面使用了该元注解的注解，表示那个类的子类也能继承该注解，有点绕，但是就是这样的</p><p>@Documented 表示允许javadoc生成文档</p><p>这样，注解就定义好了。</p><h5 id="注解实现"><a href="#注解实现" class="headerlink" title="注解实现"></a>注解实现</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * @author CongZ</span><br><span class="line"> * @classname DataSourceControllerAop</span><br><span class="line"> * @create 2019/5/21</span><br><span class="line"> **/</span><br><span class="line">@Aspect</span><br><span class="line">@EnableAspectJAutoProxy(exposeProxy = true, proxyTargetClass = true)</span><br><span class="line">@Component</span><br><span class="line">public class DataSourceControllerAop implements PriorityOrdered &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 使用aop切面，</span><br><span class="line">     * @param jp</span><br><span class="line">     */</span><br><span class="line">    @Before(&quot;execution(* com.mybatis..*Controller.*(..))&quot; +</span><br><span class="line">            &quot; &amp;&amp; (@annotation(com.mybatis.datasource.ReadDataSource))&quot; +</span><br><span class="line">            &quot; &amp;&amp; (@annotation(org.springframework.web.bind.annotation.RequestMapping))&quot;)</span><br><span class="line">    public void setReadDataSourceBefore(JoinPoint jp) &#123;</span><br><span class="line">        String rw = DataSourceContextHolder.getReadOrWrite();</span><br><span class="line">        if (!DataSourceType.write.getType().equals(rw)) &#123;</span><br><span class="line">            //输出切点信息 便于问题跟踪</span><br><span class="line">            DataSourceContextHolder.setRead();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    @After(&quot;execution(* com.mybatis..*Controller.*(..))&quot; +</span><br><span class="line">            &quot; &amp;&amp; (@annotation(com.mybatis.datasource.ReadDataSource))&quot; +</span><br><span class="line">            &quot; &amp;&amp; (@annotation(org.springframework.web.bind.annotation.RequestMapping))&quot;)</span><br><span class="line">    public void clearReadDataSourceAfter(JoinPoint jp)  &#123;</span><br><span class="line">        //方法执行完成后 清除线程上的读写key</span><br><span class="line">        DataSourceContextHolder.clear();</span><br><span class="line">    &#125;</span><br><span class="line">    /**</span><br><span class="line">     * PriorityOrdered是个接口，继承自Ordered接口，未定义任何方法。</span><br><span class="line">     * 返回的order值越小，表示优先级越高</span><br><span class="line">     * @return</span><br><span class="line">     */</span><br><span class="line">    @Override</span><br><span class="line">    public int getOrder() &#123;</span><br><span class="line">        return 1;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个注解是用的aop切面来实现的，定位到使用过这个注解的方法，然后织入进去，具体的AOP我会在下一章分析</p><p>这里就不谈一些切面的注解了，留在谈AOP的时候在去看看。</p><p>额，好像必须要谈一个@Before这注解，表示在方法执行前先调用这个方法，还有@After表示方法执行之后去调用这个方法</p><p>这里可以看到DataSourceContextHolder.getReadOrWrite()会去获取此时数据库上下文的读写状态，如果为写的话，则要改成读，具体源码在下面，先来说说原理</p><p>这里其实有一个疑点，当获取到读写状态时，应该都是为空的，因为放该方法执行完之后，会去clear一下，所以这里可以理解为，当上下文的读写状态为空时，则切换到从库上面去</p><p>然后@After就是当前方法执行之后需要去清空一下上下文的状态</p><p>可以看到这里会继承一个PriorityOrdered的类，然后实现getOrder方法，这个表示该事物的优先级别，返回的order值越小，表示优先级越高，还有继承了PriortityOrdered的接口比Ordered的接口优先级要高</p><p>好，这个讲完了，在看一下上下文的切换</p><h5 id="读写切换"><a href="#读写切换" class="headerlink" title="读写切换"></a>读写切换</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * @author CongZ</span><br><span class="line"> * @classname 本地线程，用于数据源切换上下文</span><br><span class="line"> * @create 2019/5/21</span><br><span class="line"> **/</span><br><span class="line"></span><br><span class="line">public class DataSourceContextHolder &#123;</span><br><span class="line"></span><br><span class="line">    //线程本地环境</span><br><span class="line">    private static final ThreadLocal&lt;String&gt; local = new ThreadLocal&lt;String&gt;();</span><br><span class="line"></span><br><span class="line">    public static ThreadLocal&lt;String&gt; getLocal() &#123;</span><br><span class="line">        return local;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 读库</span><br><span class="line">     */</span><br><span class="line">    public static void setRead() &#123;</span><br><span class="line">        local.set(DataSourceType.read.getType());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 写库</span><br><span class="line">     */</span><br><span class="line">    public static void setWrite() &#123;</span><br><span class="line">        local.set(DataSourceType.write.getType());</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">    public static String getReadOrWrite() &#123;</span><br><span class="line">        return local.get();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void clear() &#123;</span><br><span class="line">        local.remove();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里其实没什么，只是使用了ThreadLocal去维护变量，用这个的好处就是它会为每个线程提供一个独立的副本，所以每个线程都能独立的改变自己的副本，而不会影响其他线程所对应的副本</p><h5 id="数据源的枚举"><a href="#数据源的枚举" class="headerlink" title="数据源的枚举"></a>数据源的枚举</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">public enum DataSourceType &#123;</span><br><span class="line"></span><br><span class="line">    read(&quot;read&quot;, &quot;从库&quot;),</span><br><span class="line">    write(&quot;write&quot;,&quot;主库&quot;);</span><br><span class="line"></span><br><span class="line">    private String type;</span><br><span class="line"></span><br><span class="line">    private String name;</span><br><span class="line"></span><br><span class="line">    DataSourceType(String type, String name) &#123;</span><br><span class="line">        this.type = type;</span><br><span class="line">        this.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public String getType() &#123;</span><br><span class="line">        return type;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setType(String type) &#123;</span><br><span class="line">        this.type = type;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public String getName() &#123;</span><br><span class="line">        return name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setName(String name) &#123;</span><br><span class="line">        this.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>就两个库，如果需要添加，继续添加枚举就好了</p><h5 id="Druid配置"><a href="#Druid配置" class="headerlink" title="Druid配置"></a>Druid配置</h5><p>接下来的两个是重头戏，需要自定义配置两个东西，一个是Druid数据库连接池，第二个是Mybatis的配置</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line">    @Value(&quot;$&#123;mysql.datasource.type&#125;&quot;)</span><br><span class="line">    private Class&lt;? extends DataSource&gt; dataSourceType;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line">     * 写库 数据源配置</span><br><span class="line">     *</span><br><span class="line">     * @return</span><br><span class="line">     */</span><br><span class="line">    @Bean(name = &quot;writeDataSource&quot;)</span><br><span class="line">    @Primary</span><br><span class="line">    @ConfigurationProperties(prefix = &quot;mysql.datasource.write&quot;)</span><br><span class="line">    public DataSource writeDataSource() &#123;</span><br><span class="line">        log.info(&quot;-------------------- writeDataSource init ---------------------&quot;);</span><br><span class="line">        DataSourceBuilder dataSourceBuilder = DataSourceBuilder.create();</span><br><span class="line">        dataSourceBuilder.type(dataSourceType);</span><br><span class="line">        DruidDataSource druidDataSource = (DruidDataSource) dataSourceBuilder.build();</span><br><span class="line">        druidDataSource.setMaxActive(30);</span><br><span class="line">        druidDataSource.setInitialSize(5);</span><br><span class="line">        druidDataSource.setMaxWait(60000);</span><br><span class="line">        druidDataSource.setMinIdle(5);</span><br><span class="line">        druidDataSource.setTimeBetweenEvictionRunsMillis(60000);</span><br><span class="line">        druidDataSource.setMinEvictableIdleTimeMillis(1200000);</span><br><span class="line">        druidDataSource.setValidationQuery(&quot;select 1&quot;);</span><br><span class="line">        druidDataSource.setTestWhileIdle(true);</span><br><span class="line">        druidDataSource.setTestOnBorrow(true);</span><br><span class="line">        druidDataSource.setTestOnReturn(false);</span><br><span class="line">        druidDataSource.setPoolPreparedStatements(true);</span><br><span class="line">        druidDataSource.setMaxOpenPreparedStatements(20);</span><br><span class="line"></span><br><span class="line">        setFilters(druidDataSource);</span><br><span class="line">        return druidDataSource;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 有多少个从库就要配置多少个</span><br><span class="line">     *</span><br><span class="line">     * @return</span><br><span class="line">     */</span><br><span class="line">    @Bean(name = &quot;readDataSource01&quot;)</span><br><span class="line">    @ConfigurationProperties(prefix = &quot;mysql.datasource.read01&quot;)</span><br><span class="line">    public DataSource readDataSourceOne() &#123;</span><br><span class="line">        log.info(&quot;-------------------- read01 DataSourceOne init ---------------------&quot;);</span><br><span class="line">        DataSourceBuilder dataSourceBuilder = DataSourceBuilder.create();</span><br><span class="line">        dataSourceBuilder.type(dataSourceType);</span><br><span class="line">        DruidDataSource druidDataSource = (DruidDataSource) dataSourceBuilder.build();</span><br><span class="line">        druidDataSource.setMaxActive(30);</span><br><span class="line">        druidDataSource.setInitialSize(5);</span><br><span class="line">        druidDataSource.setMaxWait(60000);</span><br><span class="line">        druidDataSource.setMinIdle(5);</span><br><span class="line">        druidDataSource.setTimeBetweenEvictionRunsMillis(60000);</span><br><span class="line">        druidDataSource.setMinEvictableIdleTimeMillis(1200000);</span><br><span class="line">        druidDataSource.setValidationQuery(&quot;select 1&quot;);</span><br><span class="line">        druidDataSource.setTestWhileIdle(true);</span><br><span class="line">        druidDataSource.setTestOnBorrow(true);</span><br><span class="line">        druidDataSource.setTestOnReturn(false);</span><br><span class="line">        druidDataSource.setPoolPreparedStatements(true);</span><br><span class="line">        druidDataSource.setMaxOpenPreparedStatements(20);</span><br><span class="line"></span><br><span class="line">        setFilters(druidDataSource);</span><br><span class="line">        return druidDataSource;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>这个相当于是配置Druid的数据源，这里有多少数据源就要配置多少数据源，然后会去Mybatis的配置里面动态切换。</p><p>这个@ConfigurationProperties(prefix = “mysql.datasource.write”)：作用就是将 全局配置文件中 前缀为 mysql.datasource.write的属性值注入到 com.alibaba.druid.pool.DruidDataSource 的同名参数中，然后下面一个read01同理</p><p>到这里我们的数据源，和动态切换都写好了，在就去配置Myabtis了,让他也能动态切换Druid里面配置的多个数据源</p><h5 id="Mybatis自定义配置"><a href="#Mybatis自定义配置" class="headerlink" title="Mybatis自定义配置"></a>Mybatis自定义配置</h5><p>在看这段代码的时候，着实下了一番功夫，不理解Mybatis的原理和sqlSessionFactory的用处导致很难懂</p><p>来看看代码</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * @author CongZ</span><br><span class="line"> * @classname 自定义的Mybatis配置</span><br><span class="line"> * @create 2019/5/21</span><br><span class="line"> **/</span><br><span class="line">@Configuration</span><br><span class="line">@AutoConfigureAfter(DruidDoubleSourceConfiguration.class)</span><br><span class="line">@MapperScan(basePackages = &#123;&quot;com.mybatis.demo.*.dao&quot;&#125;)</span><br><span class="line">public class MybatisConfiguration extends MybatisAutoConfiguration &#123;</span><br><span class="line"></span><br><span class="line">    private static Logger log = LoggerFactory.getLogger(MybatisConfiguration.class);</span><br><span class="line"></span><br><span class="line">    @Value(&quot;$&#123;mysql.datasource.readSize&#125;&quot;)</span><br><span class="line">    private String readDataSourceSize;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    @Value(&quot;$&#123;mybatis.mapperLocations&#125;&quot;)</span><br><span class="line">    private String mybatisMapperLocations;</span><br><span class="line"></span><br><span class="line">    @Autowired</span><br><span class="line">    @Qualifier(&quot;writeDataSource&quot;)</span><br><span class="line">    private DataSource writeDataSource;</span><br><span class="line">    @Autowired</span><br><span class="line">    @Qualifier(&quot;readDataSource01&quot;)</span><br><span class="line">    private DataSource readDataSource01;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    public MybatisConfiguration(MybatisProperties properties, ObjectProvider&lt;Interceptor[]&gt; interceptorsProvider, ResourceLoader resourceLoader, ObjectProvider&lt;DatabaseIdProvider&gt; databaseIdProvider, ObjectProvider&lt;List&lt;ConfigurationCustomizer&gt;&gt; configurationCustomizersProvider) &#123;</span><br><span class="line">        super(properties, interceptorsProvider, resourceLoader, databaseIdProvider, configurationCustomizersProvider);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Bean(name = &quot;sqlSessionFactory&quot;)</span><br><span class="line">    public SqlSessionFactory sqlSessionFactorys() throws Exception &#123;</span><br><span class="line">        log.info(&quot;--------------------  sqlSessionFactory init ---------------------&quot;);</span><br><span class="line">        try &#123;</span><br><span class="line">            SqlSessionFactoryBean sessionFactoryBean = new SqlSessionFactoryBean();</span><br><span class="line">            sessionFactoryBean.setDataSource(roundRobinDataSouceProxy());</span><br><span class="line"></span><br><span class="line">            //设置mapper.xml文件所在位置</span><br><span class="line">            Resource[] resources = new PathMatchingResourcePatternResolver().getResources(mybatisMapperLocations);</span><br><span class="line">            sessionFactoryBean.setMapperLocations(resources);</span><br><span class="line">            //设置字段和列对应 user_id -&gt; userId</span><br><span class="line">            org.apache.ibatis.session.Configuration configuration = new org.apache.ibatis.session.Configuration();</span><br><span class="line">            configuration.setMapUnderscoreToCamelCase(true);</span><br><span class="line">            sessionFactoryBean.setConfiguration(configuration);</span><br><span class="line">            return sessionFactoryBean.getObject();</span><br><span class="line">        &#125; catch (IOException e) &#123;</span><br><span class="line">            log.error(&quot;mybatis resolver mapper*xml is error&quot;, e);</span><br><span class="line">            return null;</span><br><span class="line">        &#125; catch (Exception e) &#123;</span><br><span class="line">            log.error(&quot;mybatis sqlSessionFactoryBean create error&quot;, e);</span><br><span class="line">            return null;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    /**</span><br><span class="line">     * 把所有数据库都放在路由中</span><br><span class="line">     * @return</span><br><span class="line">     */</span><br><span class="line">    @Bean(name = &quot;roundRobinDataSouceProxy&quot;)</span><br><span class="line">    public AbstractRoutingDataSource roundRobinDataSouceProxy() &#123;</span><br><span class="line"></span><br><span class="line">        Map&lt;Object, Object&gt; targetDataSources = new HashMap&lt;Object, Object&gt;();</span><br><span class="line">        //把所有数据库都放在targetDataSources中,注意key值要和determineCurrentLookupKey()中代码写的一至，</span><br><span class="line">        //否则切换数据源时找不到正确的数据源</span><br><span class="line">        targetDataSources.put(DataSourceType.write.getType(), writeDataSource);</span><br><span class="line">        targetDataSources.put(DataSourceType.read.getType() + &quot;1&quot;, readDataSource01);</span><br><span class="line">        final int readSize = Integer.parseInt(readDataSourceSize);</span><br><span class="line"></span><br><span class="line">        //路由类，寻找对应的数据源</span><br><span class="line">        AbstractRoutingDataSource proxy = new AbstractRoutingDataSource() &#123;</span><br><span class="line">            private AtomicInteger count = new AtomicInteger(0);</span><br><span class="line"></span><br><span class="line">            /**</span><br><span class="line">             * 这是AbstractRoutingDataSource类中的一个抽象方法，</span><br><span class="line">             * 而它的返回值是你所要用的数据源dataSource的key值，有了这个key值，</span><br><span class="line">             * targetDataSources就从中取出对应的DataSource，如果找不到，就用配置默认的数据源。</span><br><span class="line">             */</span><br><span class="line">            @Override</span><br><span class="line">            protected Object determineCurrentLookupKey() &#123;</span><br><span class="line">                String typeKey = DataSourceContextHolder.getReadOrWrite();</span><br><span class="line">                if (typeKey == null) &#123;</span><br><span class="line">                    return DataSourceType.write.getType();</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                if (typeKey.equals(DataSourceType.write.getType())) &#123;</span><br><span class="line">                    return DataSourceType.write.getType();</span><br><span class="line">                &#125;</span><br><span class="line">                //读库， 简单负载均衡</span><br><span class="line">                int number = count.getAndAdd(1);</span><br><span class="line">                int lookupKey = number % readSize;</span><br><span class="line">                return DataSourceType.read.getType() + (lookupKey + 1);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        proxy.setDefaultTargetDataSource(writeDataSource);//默认库</span><br><span class="line">        proxy.setTargetDataSources(targetDataSources);</span><br><span class="line">        return proxy;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    @Bean</span><br><span class="line">    public SqlSessionTemplate sqlSessionTemplate(SqlSessionFactory sqlSessionFactory) &#123;</span><br><span class="line">        return new SqlSessionTemplate(sqlSessionFactory);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //事务管理</span><br><span class="line">    @Bean</span><br><span class="line">    public PlatformTransactionManager annotationDrivenTransactionManager() &#123;</span><br><span class="line">        return new DataSourceTransactionManager(roundRobinDataSouceProxy());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个注解表示当spring加载完DruidDoubleSourceConfiguration.class这个类的时候在去加载Mybatis的自定义配置类，意思就是，先把数据源的配置加载完，在去使用这个配置</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">@AutoConfigureAfter(DruidDoubleSourceConfiguration.class)</span><br></pre></td></tr></table></figure><p>这里就会使用到刚才配置的两个数据源了</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">@Autowired</span><br><span class="line">   @Qualifier(&quot;writeDataSource&quot;)</span><br><span class="line">   private DataSource writeDataSource;</span><br><span class="line">   @Autowired</span><br><span class="line">   @Qualifier(&quot;readDataSource01&quot;)</span><br><span class="line">   private DataSource readDataSource01;</span><br></pre></td></tr></table></figure><p>然后我们需要继承MybatisAutoConfiguration这个类，这里明白了一个东西，就是当父类的构造方法有参数，或者有重载时，子类必须先通过super调用父类的构造方法，而且需要放在子类构造方法的第一行，不然报错</p><p>这里面的重点在于AbstractRoutingDataSource这个的实现，扩展这个类会实现里面的一个抽象方法determineCurrentLookupKey()，这个方法会返回数据源的一个key值，然后上面填充的targetDataSources</p><p>Map,当返回了key值之后，就会去匹配targetDataSources里面的key值，如果有，就使用，没有的话，就默认使用写库，就是主库，这里就会返回一个数据源</p><p>因为mybatis不能满足我们现有的需求，所以也重新写了一个sqlSeesionFactory里面会指定roundRobinDataSouceProxy返回的一个数据源。这个是创建sqlSession的实例工厂。</p><p>然后通过sqlSessionTemplate注入sqlSessionFactorry实例</p><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>到这里就基本完成了自定义注解实现读写分离，代码不难，主要是思路，至少知道了自定义注解怎么写，怎么实现，以及mybatis的自定义配置和Druid的自定义配置</p>]]></content>
      
      
      <categories>
          
          <category> JAVA </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 自定义注解 </tag>
            
            <tag> mybatis </tag>
            
            <tag> 读写分离 </tag>
            
            <tag> AOP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LinkedHashMap表层分析</title>
      <link href="/LinkedHashMap%E8%A1%A8%E5%B1%82%E5%88%86%E6%9E%90.html"/>
      <url>/LinkedHashMap%E8%A1%A8%E5%B1%82%E5%88%86%E6%9E%90.html</url>
      
        <content type="html"><![CDATA[<p><img src="/LinkedHashMap表层分析/1.png" alt="img"></p><p>LinkedHashMap可以理解为HashMap+LinkedList组成的</p><p>有HashMap的数据结构，也有LinkedList维护插入元素的先后顺序</p><p>LinkedHashMap其中有很多方法是重用HashMap里面的，在此只分析有区别部分</p><h4 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * The head (eldest) of the doubly linked list.</span><br><span class="line"> * 头节点</span><br><span class="line"> */</span><br><span class="line">transient LinkedHashMap.Entry&lt;K,V&gt; head;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * The tail (youngest) of the doubly linked list.</span><br><span class="line"> * 尾节点</span><br><span class="line"> */</span><br><span class="line">transient LinkedHashMap.Entry&lt;K,V&gt; tail;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * The iteration ordering method for this linked hash map: &lt;tt&gt;true&lt;/tt&gt;</span><br><span class="line"> * for access-order, &lt;tt&gt;false&lt;/tt&gt; for insertion-order.</span><br><span class="line"> * true则表示按照基于访问的顺序来排列，意思就是最近使用的entry，放在链表的最末尾</span><br><span class="line"> * false则表示按照插入顺序来</span><br><span class="line"> * @serial</span><br><span class="line"> */</span><br><span class="line">final boolean accessOrder;</span><br></pre></td></tr></table></figure><h4 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h4><p>LinkedHashMap没有重写插入的put方法，而是直接调用的HashMap方法里面的put方法<br>但是HashMap里面的putVal方法newNode的时候,被LinkedHashMap里面的newNode重写了</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">Node&lt;K,V&gt; newNode(int hash, K key, V value, Node&lt;K,V&gt; e) &#123;</span><br><span class="line">    //LinkedHashMap在调用put的时候，会调用这个newNode方法</span><br><span class="line">    //这里新建了一个LinkedHashMap下面的Entry节点，维护有before, after这两个节点</span><br><span class="line">    //保证了数据插入的顺序</span><br><span class="line">    LinkedHashMap.Entry&lt;K,V&gt; p =</span><br><span class="line">        new LinkedHashMap.Entry&lt;K,V&gt;(hash, key, value, e);</span><br><span class="line">    //将数据放到list的最后面    </span><br><span class="line">    linkNodeLast(p);</span><br><span class="line">    return p;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">// link at the end of list</span><br><span class="line">private void linkNodeLast(LinkedHashMap.Entry&lt;K,V&gt; p) &#123;</span><br><span class="line">    //获取到最后一个节点</span><br><span class="line">    LinkedHashMap.Entry&lt;K,V&gt; last = tail;</span><br><span class="line">    //将p节点放到最后</span><br><span class="line">    tail = p;</span><br><span class="line">    //如果last为null,表示该节点为null,则将p节点也放到头节点上</span><br><span class="line">    if (last == null)</span><br><span class="line">        head = p;</span><br><span class="line">    else &#123;</span><br><span class="line">        //维护先后顺序</span><br><span class="line">        //将p的上一个节点设置为在为插入之前的最后一个节点</span><br><span class="line">        p.before = last;</span><br><span class="line">        //将未插入之前的最后一个节点的后节点设置为p</span><br><span class="line">        last.after = p;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>LinkedHashMap也没有重写removeNode，删除的代码复用，只是调用了afterNodeRemoval去维护双向链表保证列表顺序</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">void afterNodeRemoval(Node&lt;K,V&gt; e) &#123; // unlink</span><br><span class="line">    LinkedHashMap.Entry&lt;K,V&gt; p =</span><br><span class="line">        (LinkedHashMap.Entry&lt;K,V&gt;)e, b = p.before, a = p.after;</span><br><span class="line">    p.before = p.after = null;</span><br><span class="line">    //如果e节点的before为null</span><br><span class="line">    //标识e节点为第一个，被删除之后，e节点的after节点（后一个节点）前移，变成第一个节点</span><br><span class="line">    if (b == null)</span><br><span class="line">        head = a;</span><br><span class="line">    else</span><br><span class="line">    //如果不为null，则将e节点的后一个节点设置成b节点的下一个节点，中间去掉e的连接</span><br><span class="line">        b.after = a;</span><br><span class="line">    if (a == null)</span><br><span class="line">    //如果e为后面节点为null,则去掉e之后，b为最后一个节点</span><br><span class="line">        tail = b;</span><br><span class="line">    else</span><br><span class="line">    //a节点的前面就要去连b节点</span><br><span class="line">        a.before = b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">public V get(Object key) &#123;</span><br><span class="line">    Node&lt;K,V&gt; e;</span><br><span class="line">    //调用的是HashMap里面的getNode</span><br><span class="line">    if ((e = getNode(hash(key), key)) == null)</span><br><span class="line">        return null;</span><br><span class="line">    //如果是按照使用的顺序排列则需要去重新排列一下   </span><br><span class="line">    if (accessOrder)</span><br><span class="line">        afterNodeAccess(e);</span><br><span class="line">    return e.value;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">void afterNodeAccess(Node&lt;K,V&gt; e) &#123; // move node to last 将e节点移到最后</span><br><span class="line">    LinkedHashMap.Entry&lt;K,V&gt; last;</span><br><span class="line">    //如果e节点不是最后一个</span><br><span class="line">    if (accessOrder &amp;&amp; (last = tail) != e) &#123;</span><br><span class="line">        LinkedHashMap.Entry&lt;K,V&gt; p =</span><br><span class="line">            (LinkedHashMap.Entry&lt;K,V&gt;)e, b = p.before, a = p.after;</span><br><span class="line">       //先将p节点的后面设置为null,因为p节点被访问之后 就会被放到最后     </span><br><span class="line">        p.after = null;</span><br><span class="line">        //如果b等于null,则证明e前面没有节点，则将e后面的节点放到前面去</span><br><span class="line">       //反之将e节点的下一个节点a连到b的后节点上去 </span><br><span class="line">        if (b == null)</span><br><span class="line">            head = a;</span><br><span class="line">        else</span><br><span class="line">            b.after = a;</span><br><span class="line">        // 如果e的后面不为null,则要将a的前节点连到b</span><br><span class="line">        //否则标识e就是最后一个节点，则将b放到last</span><br><span class="line">        if (a != null)</span><br><span class="line">            a.before = b;</span><br><span class="line">        else</span><br><span class="line">            last = b;</span><br><span class="line">        //如果last为null,表示e前面也没有节点，则将p放到head</span><br><span class="line">        //反之将e节点的之前设置为last</span><br><span class="line">        //last之后的节点设置为p    </span><br><span class="line">        if (last == null)</span><br><span class="line">            head = p;</span><br><span class="line">        else &#123;</span><br><span class="line">            p.before = last;</span><br><span class="line">            last.after = p;</span><br><span class="line">        &#125;</span><br><span class="line">        tail = p;</span><br><span class="line">        ++modCount;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="测试用例"><a href="#测试用例" class="headerlink" title="测试用例"></a>测试用例</h4><p>LinkedHashMap是在HashMap的基础上面，维护了一条双向链表，保证了LinkedHashMap的插入的顺序和遍历的顺序</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">//HashMap插入和读取都是无序状态</span><br><span class="line">Map&lt;String,Object&gt; map=new HashMap&lt;&gt;();</span><br><span class="line">for (int i=0;i&lt;10000;i++)&#123;</span><br><span class="line">    map.put(&quot;key&quot;+i,i);</span><br><span class="line">&#125;</span><br><span class="line">Iterator map1it=map.entrySet().iterator();</span><br><span class="line">while(map1it.hasNext())</span><br><span class="line">&#123;</span><br><span class="line">    Map.Entry&lt;String, Object&gt; entry= (Map.Entry&lt;String, Object&gt; )map1it.next();</span><br><span class="line">    System.out.println(&quot;Key: &quot;+entry.getKey()+&quot; Value: &quot;+entry.getValue());</span><br><span class="line">&#125;</span><br><span class="line">//LinkedHashMap有维护一个双向链表，插入和读取都是有序状态</span><br><span class="line">Map&lt;String,Object&gt; linkedmap=new LinkedHashMap&lt;&gt;();</span><br><span class="line">for (int i=0;i&lt;10000;i++)&#123;</span><br><span class="line">    linkedmap.put(&quot;key&quot;+i,i);</span><br><span class="line">&#125;</span><br><span class="line">Iterator linkedmaplit=linkedmap.entrySet().iterator();</span><br><span class="line">while(linkedmaplit.hasNext())</span><br><span class="line">&#123;</span><br><span class="line">    Map.Entry&lt;String, Object&gt; entry= (Map.Entry&lt;String, Object&gt; )linkedmaplit.next();</span><br><span class="line">    System.out.println(&quot;Key: &quot;+entry.getKey()+&quot; Value: &quot;+entry.getValue());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="LRU算法"><a href="#LRU算法" class="headerlink" title="LRU算法"></a>LRU算法</h4><p>LRU（Least recently used，最近最少使用）算法根据数据的历史访问记录来进行淘汰数据，其核心思想是“如果数据最近被访问过，那么将来被访问的几率也更高 </p>]]></content>
      
      
      <categories>
          
          <category> JAVA </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JAVA </tag>
            
            <tag> 源码 </tag>
            
            <tag> 集合 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ConcurrentHashMap表层分析</title>
      <link href="/ConcurrentHashMap%E8%A1%A8%E5%B1%82%E5%88%86%E6%9E%90.html"/>
      <url>/ConcurrentHashMap%E8%A1%A8%E5%B1%82%E5%88%86%E6%9E%90.html</url>
      
        <content type="html"><![CDATA[<h4 id="是什么？"><a href="#是什么？" class="headerlink" title="是什么？"></a>是什么？</h4><p>一个支持并发的集合，其实ConcurrentHashMap和HashMap的思路差不多，只不过HashMap不支持并发操作，而ConcurrentHashMap通过分段锁和volatile修饰，和JDK1.7相比，1.8采用了大量的CAS操作来保证线程安全，</p><p>JDK1.7版本采用了ReentrantLock+Segment+HashEntry</p><p>JDK1.8版本采用了synchronized+CAS+HashEntry+红黑树</p><p>相比较而言，两个版本更多的增加了性能方面优化</p><h4 id="区别？"><a href="#区别？" class="headerlink" title="区别？"></a>区别？</h4><p>HashMap是线程不安全的，在处理并发时会出现问题</p><p>Hashtable虽然put和get方法时加上了synchronized来保证线程安全，但是锁的粒度太大，当一个线程在put或者在get的时候，其他线程只能等待</p><p>ConcurrentHashMap在保证线程安全的同时，并没有锁住整个Map，而是采用了分段锁，只锁住了一个数组里面的一个节点，其他节点如要做put操作，没有影响</p><h4 id="源码"><a href="#源码" class="headerlink" title="源码"></a>源码</h4><h5 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h5><p>使用了volatile保证了不同线程在对这个变量同时进行操作时的可见性，</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">static class Node&lt;K,V&gt; implements Map.Entry&lt;K,V&gt; &#123;</span><br><span class="line">        final int hash;</span><br><span class="line">        final K key;</span><br><span class="line">        volatile V val;</span><br><span class="line">        volatile Node&lt;K,V&gt; next;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><h5 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">private static final int MAXIMUM_CAPACITY = 1 &lt;&lt; 30;//节点的最大的容量</span><br><span class="line">private static final int DEFAULT_CAPACITY = 16;//默认的容量</span><br><span class="line">static final int MAX_ARRAY_SIZE = Integer.MAX_VALUE - 8;//数组的最大容量</span><br><span class="line">private static final int DEFAULT_CONCURRENCY_LEVEL = 16;//默认的并发级别（弃用）</span><br><span class="line">private static final float LOAD_FACTOR = 0.75f;//负载因子</span><br><span class="line">static final int TREEIFY_THRESHOLD = 8;//和HashMap一样的链表达到多少转换为树</span><br><span class="line">static final int UNTREEIFY_THRESHOLD = 6;//逆Tree</span><br><span class="line">static final int MIN_TREEIFY_CAPACITY = 64;//桶中结构转化为红黑树对应的table的最小大小</span><br><span class="line">private static final int MIN_TRANSFER_STRIDE = 16;//步长</span><br></pre></td></tr></table></figure><h5 id="put方法"><a href="#put方法" class="headerlink" title="put方法"></a>put方法</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><span class="line">public V put(K key, V value) &#123;</span><br><span class="line">    return putVal(key, value, false);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/** Implementation for put and putIfAbsent */</span><br><span class="line">final V putVal(K key, V value, boolean onlyIfAbsent) &#123;</span><br><span class="line">    //校验参数，不能插入null值</span><br><span class="line">    if (key == null || value == null) throw new NullPointerException();</span><br><span class="line">    //计算hash</span><br><span class="line">    int hash = spread(key.hashCode());</span><br><span class="line">    //记录修改次数</span><br><span class="line">    int binCount = 0;</span><br><span class="line">    for (Node&lt;K,V&gt;[] tab = table;;) &#123;</span><br><span class="line">        Node&lt;K,V&gt; f; int n, i, fh;</span><br><span class="line">        //如果当前数组为null,则初始化数组</span><br><span class="line">        if (tab == null || (n = tab.length) == 0)</span><br><span class="line">            tab = initTable();</span><br><span class="line">        //找到那个hash对应的桶的位置，如果为null,则利用CAS修改值</span><br><span class="line">        else if ((f = tabAt(tab, i = (n - 1) &amp; hash)) == null) &#123;</span><br><span class="line">            if (casTabAt(tab, i, null,</span><br><span class="line">                         new Node&lt;K,V&gt;(hash, key, value, null)))</span><br><span class="line">                break;                   // no lock when adding to empty bin</span><br><span class="line">        &#125;</span><br><span class="line">        //如果f的hash值在扩容则则帮助数组迁移</span><br><span class="line">        else if ((fh = f.hash) == MOVED)</span><br><span class="line">            tab = helpTransfer(tab, f);</span><br><span class="line">        else &#123;//这里就相当于修改</span><br><span class="line">            V oldVal = null;</span><br><span class="line">            //锁住那个桶的头节点</span><br><span class="line">            synchronized (f) &#123;</span><br><span class="line">                if (tabAt(tab, i) == f) &#123;</span><br><span class="line">                    //如果fh（就是上面获取的f的hash值）大于0，则表示是个链表</span><br><span class="line">                    if (fh &gt;= 0) &#123;</span><br><span class="line">                        //记录链表的长度</span><br><span class="line">                        binCount = 1;</span><br><span class="line">                        //遍历链表</span><br><span class="line">                        for (Node&lt;K,V&gt; e = f;; ++binCount) &#123;</span><br><span class="line">                            K ek;</span><br><span class="line">                            //如果找到了相等的key则将当前的e的值赋值给oldVal，以供返回</span><br><span class="line">                            if (e.hash == hash &amp;&amp;</span><br><span class="line">                                ((ek = e.key) == key ||</span><br><span class="line">                                 (ek != null &amp;&amp; key.equals(ek)))) &#123;</span><br><span class="line">                                oldVal = e.val;</span><br><span class="line">                                if (!onlyIfAbsent)</span><br><span class="line">                                    e.val = value;</span><br><span class="line">                                break;</span><br><span class="line">                            &#125;</span><br><span class="line">                            Node&lt;K,V&gt; pred = e;</span><br><span class="line">                            //如果遍历到最后一个都没有找到相同的key,则new一个节点</span><br><span class="line">                            if ((e = e.next) == null) &#123;</span><br><span class="line">                                pred.next = new Node&lt;K,V&gt;(hash, key,</span><br><span class="line">                                                          value, null);</span><br><span class="line">                                break;</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    //如果f为树，则调用树的put方法</span><br><span class="line">                    else if (f instanceof TreeBin) &#123;</span><br><span class="line">                        Node&lt;K,V&gt; p;</span><br><span class="line">                        binCount = 2;</span><br><span class="line">                        if ((p = ((TreeBin&lt;K,V&gt;)f).putTreeVal(hash, key,</span><br><span class="line">                                                       value)) != null) &#123;</span><br><span class="line">                            oldVal = p.val;</span><br><span class="line">                            if (!onlyIfAbsent)</span><br><span class="line">                                p.val = value;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            //判断链表长度</span><br><span class="line">            if (binCount != 0) &#123;</span><br><span class="line">                //判断这个链表是否要转换为红黑树，就是判断链表的长度是否大于8</span><br><span class="line">                if (binCount &gt;= TREEIFY_THRESHOLD)</span><br><span class="line">                    //这里会继续判断一下这个数组的长度是否小于64，如果小于64，则会扩容这个数组，如果大于，就会转换成红黑树</span><br><span class="line">                    treeifyBin(tab, i);</span><br><span class="line">                if (oldVal != null)</span><br><span class="line">                    return oldVal;</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    addCount(1L, binCount);</span><br><span class="line">    return null;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="get方法"><a href="#get方法" class="headerlink" title="get方法"></a>get方法</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">public V get(Object key) &#123;</span><br><span class="line">    Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; e, p; int n, eh; K ek;</span><br><span class="line">    //取key的hash</span><br><span class="line">    int h = spread(key.hashCode());</span><br><span class="line">    //判断不为空</span><br><span class="line">    if ((tab = table) != null &amp;&amp; (n = tab.length) &gt; 0 &amp;&amp;</span><br><span class="line">        (e = tabAt(tab, (n - 1) &amp; h)) != null) &#123;</span><br><span class="line">        if ((eh = e.hash) == h) &#123;</span><br><span class="line">            //如果key相等，则返回值</span><br><span class="line">            if ((ek = e.key) == key || (ek != null &amp;&amp; key.equals(ek)))</span><br><span class="line">                return e.val;</span><br><span class="line">        &#125;</span><br><span class="line">        //正在扩容或是红黑树</span><br><span class="line">        else if (eh &lt; 0)</span><br><span class="line">            //查找值</span><br><span class="line">            return (p = e.find(h, key)) != null ? p.val : null;</span><br><span class="line">        //遍历链表</span><br><span class="line">        while ((e = e.next) != null) &#123;</span><br><span class="line">            if (e.hash == h &amp;&amp;</span><br><span class="line">                ((ek = e.key) == key || (ek != null &amp;&amp; key.equals(ek))))</span><br><span class="line">                return e.val;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return null;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="initTable方法"><a href="#initTable方法" class="headerlink" title="initTable方法"></a>initTable方法</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Initializes table, using the size recorded in sizeCtl.</span><br><span class="line"> */</span><br><span class="line">private final Node&lt;K,V&gt;[] initTable() &#123;</span><br><span class="line">    Node&lt;K,V&gt;[] tab; int sc;</span><br><span class="line">    while ((tab = table) == null || tab.length == 0) &#123;</span><br><span class="line">        if ((sc = sizeCtl) &lt; 0)</span><br><span class="line">            Thread.yield(); // lost initialization race; just spin</span><br><span class="line">        //CAS一下，将sizeCtl改为-1表示锁</span><br><span class="line">        else if (U.compareAndSwapInt(this, SIZECTL, sc, -1)) &#123;</span><br><span class="line">            try &#123;</span><br><span class="line">                if ((tab = table) == null || tab.length == 0) &#123;</span><br><span class="line">                    //如果sc大于0，则用sc，反之用默认的容量大小  16</span><br><span class="line">                    int n = (sc &gt; 0) ? sc : DEFAULT_CAPACITY;</span><br><span class="line">                    @SuppressWarnings(&quot;unchecked&quot;)</span><br><span class="line">                    //new一个16为长度的数组</span><br><span class="line">                    Node&lt;K,V&gt;[] nt = (Node&lt;K,V&gt;[])new Node&lt;?,?&gt;[n];</span><br><span class="line">                    //复制给全局的table,table是有volatile修饰的，保证内存可见性</span><br><span class="line">                    table = tab = nt;</span><br><span class="line">                    // 如果 n 为 16 的话，那么这里 sc = 12</span><br><span class="line">                    // 其实就是 0.75 * n</span><br><span class="line">                    sc = n - (n &gt;&gt;&gt; 2);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; finally &#123;</span><br><span class="line">                //设置sizeCtl为sc是12</span><br><span class="line">                sizeCtl = sc;</span><br><span class="line">            &#125;</span><br><span class="line">            break;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return tab;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> JAVA </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JAVA </tag>
            
            <tag> 源码 </tag>
            
            <tag> 集合 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java动态代理</title>
      <link href="/Java%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86.html"/>
      <url>/Java%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86.html</url>
      
        <content type="html"><![CDATA[<p>​    最近在看Mybatis时，对mapper怎么映射到dao层联想到前公司内部的.net ORM框架，研究过.net ORM框架</p><p>在来看看java里面的mybatis是大致怎么样的一个实现原理，来简答解释一下java里面的动态代理机制</p><p>​    Mapper的XML文件和Mapper的接口，在使用过程中，我们往往只需要实例化一个Mapper对象，然后调用对象里面的接口，即可执行XML里面的sql,这中间Mapper肯定是有一个代理类，去帮助我们找到XML文件里面的SQL。</p><h4 id="JDK动态代理"><a href="#JDK动态代理" class="headerlink" title="JDK动态代理"></a>JDK动态代理</h4><h5 id="是什么？"><a href="#是什么？" class="headerlink" title="是什么？"></a>是什么？</h5><p>​    动态代理可以将一个类里面的不同的方法统一集中到一个方法里面去执行，做一些其他的事情，对于调用者是感受不到，主要是使用了反射获取到一个接口类里面的所有公有或私有方法，来针对这些方法去创建动态代理对象。</p><p>​    JDK动态代理在java.lang.reflect.*这个包下，实现JDK动态代理主要涉及到两个类</p><p>​    1.InvocationHandler:这个接口中只有一个方法，invoke这个方法第一个参数proxy是代理类的实例，method是需要代理的方法，args是该方法的参数，</p><p>​    2.Proxy:动态代理类，代理类需要实现InvocationHandler这个类，必须实现invoke这个方法</p><h5 id="动态代理实现Mybatis简单功能"><a href="#动态代理实现Mybatis简单功能" class="headerlink" title="动态代理实现Mybatis简单功能"></a>动态代理实现Mybatis简单功能</h5><p>主方法</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String[] args) &#123;  </span><br><span class="line">    MySqlsession sqlsession=new MySqlsession();</span><br><span class="line">    /***</span><br><span class="line">     * 调用getMapper的时候，就会返回一个UserMapper的动态代理对象</span><br><span class="line">     * 当需要调用UserMapper类里面的任何方法的时候，都会被代理到MyMapperProxy的invoke方法里面</span><br><span class="line">     *</span><br><span class="line">     */</span><br><span class="line">    UserMapper mapper = sqlsession.getMapper(UserMapper.class);</span><br><span class="line">    User user = mapper.getUserById(&quot;2&quot;);  </span><br><span class="line">    System.out.println(user);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在去看看getMapper方法里面</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">   /***</span><br><span class="line">    * 动态代理调用</span><br><span class="line">    * @param clas</span><br><span class="line">    * @param &lt;T&gt;</span><br><span class="line">    * @return</span><br><span class="line">    */</span><br><span class="line">   @SuppressWarnings(&quot;unchecked&quot;)</span><br><span class="line">public &lt;T&gt; T getMapper(Class&lt;T&gt; clas)&#123;</span><br><span class="line">       /***</span><br><span class="line">        * clas 一个classLoader对象，定义由哪个ClassLoader对象生成的代理类进行加载</span><br><span class="line">        * 一个interfaces的接口数组，提供newProxyInstance，代理类就会实现这个接口的所有方法</span><br><span class="line">        * InvocationHandler对象，当动态代理调用到接口里面的方法时，会关联到哪个invocaionHandler对象，由里面的invoke去处理</span><br><span class="line">        */</span><br><span class="line">       return (T)Proxy.newProxyInstance(clas.getClassLoader(),new Class[]&#123;clas&#125;,</span><br><span class="line">       new MyMapperProxy(myConfiguration,this));  </span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>通过Proxy.newProxyInstance去新建了一个动态代理类</p><p>实例了该动态代理类的接口，在调用的过程中，会首先进入到invoke方法里面，去由invoke统一执行</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">/***</span><br><span class="line"> * 实现InvocationHandler需要重写invoke</span><br><span class="line"> *</span><br><span class="line"> * 这里面通过反射会去获取到UserMapper.xml里面的所有查询，放到MapperBean里面</span><br><span class="line"> * 根据外层需要调用的方法名去遍历MapperBean里面的名字，在去根据不同的方法执行不同的SQL</span><br><span class="line"> * @param proxy 代理对象</span><br><span class="line"> * @param method 代理对象执行的方法</span><br><span class="line"> * @param args 代理对象执行方法的参数</span><br><span class="line"> * @return</span><br><span class="line"> * @throws Throwable</span><br><span class="line"> */</span><br><span class="line">@Override</span><br><span class="line">public Object invoke(Object proxy, Method method, Object[] args) throws Throwable &#123;</span><br><span class="line">System.out.println(&quot;进入invoke&quot;);</span><br><span class="line">MapperBean readMapper = myConfiguration.readMapper(&quot;UserMapper.xml&quot;);</span><br><span class="line">//是否是xml文件对应的接口</span><br><span class="line">if(!method.getDeclaringClass().getName().equals(readMapper.getInterfaceName()))&#123;</span><br><span class="line">return null;  </span><br><span class="line">&#125;</span><br><span class="line">List&lt;Function&gt; list = readMapper.getList();</span><br><span class="line">if(null != list || 0 != list.size())&#123;</span><br><span class="line">for (Function function : list) &#123;</span><br><span class="line">//id是否和接口方法名一样</span><br><span class="line"> if(method.getName().equals(function.getFuncName()))&#123;  </span><br><span class="line">            return mySqlsession.selectOne(function.getSql(), String.valueOf(args[0]));  </span><br><span class="line">        &#125;  </span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">    return null;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="能做什么？"><a href="#能做什么？" class="headerlink" title="能做什么？"></a>能做什么？</h5><p>一般在业务上面很少会使用到动态代理，但是理解动态代理之后很容易帮助我们理解一些Spring内部的一些机制，包括Mybatis的部分模块</p><h6 id="AOP"><a href="#AOP" class="headerlink" title="AOP"></a>AOP</h6><p>AOP面向切面编程 即在一个增强的方法前后加上一些需要特殊处理的事情，使用动态代理，在执行方法的前后加上需要增强的事情</p><h6 id="RPC"><a href="#RPC" class="headerlink" title="RPC"></a>RPC</h6><p>RPC远程过程调用，在调用远程方法时，就像调用平常的方法一样，只是调用者不用关心调用的方法在哪，和具体的实现，这中间的事由一个处理中心去处理，在由处理中心去调用具体的实现方法</p><p>举一个WCF的例子，在web端调用服务端的方法，只用配置服务的路径，以及服务使用的协议，通过注册中心去分配任务</p><h6 id="设计模式"><a href="#设计模式" class="headerlink" title="设计模式"></a>设计模式</h6><p>代理模式和装饰器模式</p>]]></content>
      
      
      <categories>
          
          <category> JAVA </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JAVA </tag>
            
            <tag> 动态代理 </tag>
            
            <tag> Mybatis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>HashMap表层分析</title>
      <link href="/HashMap%E8%A1%A8%E5%B1%82%E5%88%86%E6%9E%90.html"/>
      <url>/HashMap%E8%A1%A8%E5%B1%82%E5%88%86%E6%9E%90.html</url>
      
        <content type="html"><![CDATA[<h2 id="HashMap简单分析"><a href="#HashMap简单分析" class="headerlink" title="HashMap简单分析"></a>HashMap简单分析</h2><p><img src="/HashMap表层分析/1.png" alt></p><h4 id="是什么"><a href="#是什么" class="headerlink" title="是什么?"></a>是什么?</h4><p>HashMap是通过一个数组和链表加上红黑树来实现的，通过计算散列码（hash）来决定存储位置，所以查询时只用根据散列码去找到指定的值，速度会比较快</p><p>当hash冲突之后 HashMap会自动转换成链表来解决hash冲突，jdk1.8版本之后HashMap的实现方式是数组和链表加红黑树来实现，当链表节点长度达到一定程度（8）时，会自动扩展成红黑树</p><p>这里得说一下JDK1.7版本的HashMap</p><p>1.7版本有一个缺点，就是当Hash冲突的时候，就会在当前桶上面创建链表，这样链表会越来越长，然后查询的效率会越来越低</p><p>1.7版本是采用的头插法，在插入时，新元素会放在链表头部，会改变链表上面的顺醋，如果扩容后，重新计算hash，则有可能会导致循环链路。例A节点的next指向B,B节点next指向C，C节点next指向A。1.8之后全部采用尾插法</p><h4 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h4><p>如果键值A计算得到的hash为1，放到map里面去，如果键值为B计算得到的hash也为1，此时hash冲突，B就会放到链表的第一个位置，A就会放到后面，如果继续往数组里面添加B，他的hash码一样，他的键值也一样，则会覆盖原来的值</p><h3 id="源码"><a href="#源码" class="headerlink" title="源码"></a>源码</h3><h4 id="基本属性"><a href="#基本属性" class="headerlink" title="基本属性"></a>基本属性</h4><p>数据结构</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">static class Node&lt;K,V&gt; implements Map.Entry&lt;K,V&gt; &#123;</span><br><span class="line">        final int hash;</span><br><span class="line">        final K key;</span><br><span class="line">        V value;</span><br><span class="line">        Node&lt;K,V&gt; next;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>默认初始的容量 因为底层的数组的实现，所以就是数组的默认大小</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DEFAULT_INITIAL_CAPACITY = <span class="number">1</span> &lt;&lt; <span class="number">4</span>; <span class="comment">// aka 16</span></span><br></pre></td></tr></table></figure><p>数组最大的容量 1073741824</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MAXIMUM_CAPACITY = <span class="number">1</span> &lt;&lt; <span class="number">30</span>;</span><br></pre></td></tr></table></figure><p>负载因子为0.75</p><p>因为HashMap的容量是有限的，在使用的过程中不断往里面存数据，当数据量达到了 <strong>容量\负载因子=16\0.75=12</strong> 时就需要进行扩容，而扩容设置的rehash，复制数据等操作，会很影响性能，所以建议提前预估好HashMap的的大小，避免扩容带来的性能损耗。</p><p>负载因子越大，Map的容量越大，填满的元素越多，空间利用率高，但是冲突的机会大了，所以链表会越来越长，导致查询的效率降低</p><p>反之，负载因子越小，Map的容量越小，很多表中的还没有用就开始扩容，那样冲突的机会小，链表不会很长，查询就相对快一点，但是不断扩容导致容量变大，内存消耗变大</p><p>取折中值，就是0.75</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">static final float DEFAULT_LOAD_FACTOR = 0.75f;</span><br></pre></td></tr></table></figure><p>存放数据的数组</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">transient Node&lt;K,V&gt;[] table;</span><br></pre></td></tr></table></figure><p>当前存放数量的大小</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">transient int size;</span><br></pre></td></tr></table></figure><p>数组的大小，可以在初始化的时候，显示指定</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int threshold;</span><br></pre></td></tr></table></figure><p>hash表的负载因子，也可以在初始化的时候指定</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">final float loadFactor;</span><br></pre></td></tr></table></figure><p>这是JDK1.8之后才有的一个属性，标识链表最大的节点，如果超过阈值，则自动将多余部分维护成红黑树</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">static final int TREEIFY_THRESHOLD = 8;</span><br></pre></td></tr></table></figure><p>红黑树节点，转换成链表阈值为6</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">static final int UNTREEIFY_THRESHOLD = 6;</span><br></pre></td></tr></table></figure><p>转红黑树时, table的最小长度</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">static final int MIN_TREEIFY_CAPACITY = 64;</span><br></pre></td></tr></table></figure><h4 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line">//所有其他字段都默认</span><br><span class="line">public HashMap() &#123;</span><br><span class="line">    this.loadFactor = DEFAULT_LOAD_FACTOR; // all other fields defaulted</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//指定Map大小，一般初始化HashMap都建议指定初始化大小</span><br><span class="line">public HashMap(int initialCapacity) &#123;</span><br><span class="line">    this(initialCapacity, DEFAULT_LOAD_FACTOR);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//指定初始化大小以及指定负载因子</span><br><span class="line">public HashMap(int initialCapacity, float loadFactor) &#123;</span><br><span class="line">//如果初始容量小于0，抛异常</span><br><span class="line">    if (initialCapacity &lt; 0)</span><br><span class="line">        throw new IllegalArgumentException(&quot;Illegal initial capacity: &quot; +</span><br><span class="line">                                           initialCapacity);</span><br><span class="line">    //初始容量不能大于默认的最大值，如果超过，则使用最大</span><br><span class="line">    if (initialCapacity &gt; MAXIMUM_CAPACITY)</span><br><span class="line">        initialCapacity = MAXIMUM_CAPACITY;</span><br><span class="line">    //负载因子不能小于等于0 或不能为其他字符，只能为数字</span><br><span class="line">    if (loadFactor &lt;= 0 || Float.isNaN(loadFactor))</span><br><span class="line">        throw new IllegalArgumentException(&quot;Illegal load factor: &quot; +</span><br><span class="line">                                           loadFactor);</span><br><span class="line">   //初始化负载因子</span><br><span class="line">    this.loadFactor = loadFactor;</span><br><span class="line">    //初始化容量</span><br><span class="line">    this.threshold = tableSizeFor(initialCapacity);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//指定一个HashMap去初始化</span><br><span class="line">public HashMap(Map&lt;? extends K, ? extends V&gt; m) &#123;</span><br><span class="line">//默认的负载因子</span><br><span class="line">    this.loadFactor = DEFAULT_LOAD_FACTOR;</span><br><span class="line">    //将m放到HashMap里面</span><br><span class="line">    putMapEntries(m, false);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">final void putMapEntries(Map&lt;? extends K, ? extends V&gt; m, boolean evict) &#123;</span><br><span class="line">    int s = m.size();</span><br><span class="line">    if (s &gt; 0) &#123;</span><br><span class="line">    //如果table为空</span><br><span class="line">        if (table == null) &#123; // pre-size</span><br><span class="line">        //算出容量</span><br><span class="line">            float ft = ((float)s / loadFactor) + 1.0F;</span><br><span class="line">            int t = ((ft &lt; (float)MAXIMUM_CAPACITY) ?</span><br><span class="line">                     (int)ft : MAXIMUM_CAPACITY);</span><br><span class="line">            //如果t大于阈值，则重新初始化阈值</span><br><span class="line">            if (t &gt; threshold)</span><br><span class="line">                threshold = tableSizeFor(t);</span><br><span class="line">        &#125;</span><br><span class="line">        //如果m的容量大于阈值，则扩容</span><br><span class="line">        else if (s &gt; threshold)</span><br><span class="line">            resize();</span><br><span class="line">        //将m的值遍历到当前的实例里面</span><br><span class="line">        for (Map.Entry&lt;? extends K, ? extends V&gt; e : m.entrySet()) &#123;</span><br><span class="line">            K key = e.getKey();</span><br><span class="line">            V value = e.getValue();</span><br><span class="line">            putVal(hash(key), key, value, false, evict);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="get方法"><a href="#get方法" class="headerlink" title="get方法"></a>get方法</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line">public V get(Object key) &#123;</span><br><span class="line">    Node&lt;K,V&gt; e;</span><br><span class="line">    return (e = getNode(hash(key), key)) == null ? null : e.value;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">final Node&lt;K,V&gt; getNode(int hash, Object key) &#123;</span><br><span class="line">    Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; first, e; int n; K k;</span><br><span class="line">    //判断这个hashmap是否为空</span><br><span class="line">    if ((tab = table) != null &amp;&amp; (n = tab.length) &gt; 0 &amp;&amp;</span><br><span class="line">        (first = tab[(n - 1) &amp; hash]) != null) &#123;</span><br><span class="line">            //判断当前节点的hash值和key是否和参数里面的key值相等</span><br><span class="line">            //如果相等，直接返回</span><br><span class="line">        if (first.hash == hash &amp;&amp; // always check first node</span><br><span class="line">            ((k = first.key) == key || (key != null &amp;&amp; key.equals(k))))</span><br><span class="line">            return first;</span><br><span class="line">            //如果当前节点的下一个节点不为null</span><br><span class="line">        if ((e = first.next) != null) &#123;</span><br><span class="line">            //判断当前节点是否为红黑树</span><br><span class="line">            if (first instanceof TreeNode)</span><br><span class="line">            //如果为红黑树则调用getTreeNode返回去返回</span><br><span class="line">                return ((TreeNode&lt;K,V&gt;)first).getTreeNode(hash, key);</span><br><span class="line">            do &#123;</span><br><span class="line">                //这里判断的是如果上面的没有找到，则不断循环到下一级去匹配，</span><br><span class="line">                //判断hash和key是否相等</span><br><span class="line">                if (e.hash == hash &amp;&amp;</span><br><span class="line">                    ((k = e.key) == key || (key != null &amp;&amp; key.equals(k))))</span><br><span class="line">                    return e;</span><br><span class="line">            &#125; while ((e = e.next) != null);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return null;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//如果是树结构，则用这个获取节点</span><br><span class="line">    final TreeNode&lt;K,V&gt; getTreeNode(int h, Object k) &#123;</span><br><span class="line">        return ((parent != null) ? root() : this).find(h, k, null);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    //树的查找方法</span><br><span class="line">    //红黑树特点：右节点&gt;根节点&gt;左节点</span><br><span class="line">    final TreeNode&lt;K,V&gt; find(int h, Object k, Class&lt;?&gt; kc) &#123;</span><br><span class="line">        TreeNode&lt;K,V&gt; p = this; //获取当前实例的树</span><br><span class="line">        //循环直到p为null</span><br><span class="line">        do &#123;</span><br><span class="line">            int ph, dir; K pk;</span><br><span class="line">            //首先获取到p的左右节点</span><br><span class="line">            TreeNode&lt;K,V&gt; pl = p.left, pr = p.right, q;</span><br><span class="line">            //如果h比p的hash值小，则将左边的值给到p,然后在去循环左边的值</span><br><span class="line">            if ((ph = p.hash) &gt; h)</span><br><span class="line">                p = pl;</span><br><span class="line">            else if (ph &lt; h) //如果大于的话，则将右边的值给到p，然后在去循环右边的值</span><br><span class="line">                p = pr;</span><br><span class="line">            else if ((pk = p.key) == k || (k != null &amp;&amp; k.equals(pk))) //如果相等则返回</span><br><span class="line">                return p;</span><br><span class="line">            else if (pl == null) //如果左边节点为空，则去循环右边的，因为最后一排可能只有一边有值</span><br><span class="line">                p = pr;</span><br><span class="line">            else if (pr == null) //同上，去循环左边的</span><br><span class="line">                p = pl;</span><br><span class="line">            else if ((kc != null ||</span><br><span class="line">                      (kc = comparableClassFor(k)) != null) &amp;&amp;</span><br><span class="line">                     (dir = compareComparables(kc, k, pk)) != 0)</span><br><span class="line">                p = (dir &lt; 0) ? pl : pr;</span><br><span class="line">            else if ((q = pr.find(h, k, kc)) != null)</span><br><span class="line">                return q;</span><br><span class="line">            else</span><br><span class="line">                p = pl;</span><br><span class="line">        &#125; while (p != null);</span><br><span class="line">        return null;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h4 id="put方法"><a href="#put方法" class="headerlink" title="put方法"></a>put方法</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line">final V putVal(int hash, K key, V value, boolean onlyIfAbsent,</span><br><span class="line">               boolean evict) &#123;</span><br><span class="line">    Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; int n, i;</span><br><span class="line">    //判断table是否为空或者长度为0，如果是则调用resize进行扩容</span><br><span class="line">    if ((tab = table) == null || (n = tab.length) == 0)</span><br><span class="line">        n = (tab = resize()).length;</span><br><span class="line">        //判断进行hash计算之后的tab索引处是否有值，如果为空则新建一个节点</span><br><span class="line">    if ((p = tab[i = (n - 1) &amp; hash]) == null)</span><br><span class="line">        tab[i] = newNode(hash, key, value, null);</span><br><span class="line">    //表示该tab索引出有值</span><br><span class="line">    else &#123;</span><br><span class="line">        Node&lt;K,V&gt; e; K k;</span><br><span class="line">        //依旧判断通过key的hashcode计算出来的hash值是否相等，还有key值是否相等</span><br><span class="line">        if (p.hash == hash &amp;&amp;</span><br><span class="line">            ((k = p.key) == key || (key != null &amp;&amp; key.equals(k))))</span><br><span class="line">        //如果相等，则证明这个key在Map里面存在，直接覆盖就好了</span><br><span class="line">            e = p;</span><br><span class="line">        //判断这个节点是否为树节点，如果为树节点，则调用putTreeVal</span><br><span class="line">        else if (p instanceof TreeNode)</span><br><span class="line">            e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(this, tab, hash, key, value);</span><br><span class="line">        else &#123;//表示p为一个普通的链表</span><br><span class="line">            for (int binCount = 0; ; ++binCount) &#123;</span><br><span class="line">                if ((e = p.next) == null) &#123;</span><br><span class="line">                    //新建一个节点。</span><br><span class="line">                    //LinkedHashMap会复写这个newNode方法，</span><br><span class="line">                    //去新建一个带有before和after的双向链表，维护列表顺序</span><br><span class="line">                    p.next = newNode(hash, key, value, null);</span><br><span class="line">                    //如果链表数量超过了转换为红黑树的阈值，在转换为红黑树</span><br><span class="line">                                     //treeifyBin里面会判断当前HashMap的长度，长度不足64则只会执行resize,即扩容数组</span><br><span class="line">                                     // 如果超过64则会转为红黑树</span><br><span class="line">                    if (binCount &gt;= TREEIFY_THRESHOLD - 1) // -1 for 1st</span><br><span class="line">                        treeifyBin(tab, hash);</span><br><span class="line">                    break;</span><br><span class="line">                &#125;</span><br><span class="line">                //这里如果找到了相等的节点，则break;</span><br><span class="line">                //不然p=e则会不断循环，一直到上面if p.next==nul,把数据插入到链表最后</span><br><span class="line">                if (e.hash == hash &amp;&amp;</span><br><span class="line">                    ((k = e.key) == key || (key != null &amp;&amp; key.equals(k))))</span><br><span class="line">                    break;</span><br><span class="line">                p = e;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        //上面给e赋值之后，如果e不为null,则证明该hash处有值，直接覆盖，返回oldvalue</span><br><span class="line">        if (e != null) &#123; // existing mapping for key</span><br><span class="line">            V oldValue = e.value;</span><br><span class="line">            if (!onlyIfAbsent || oldValue == null)</span><br><span class="line">                e.value = value;</span><br><span class="line">            afterNodeAccess(e);</span><br><span class="line">            return oldValue;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ++modCount;</span><br><span class="line">    //如果容量不够，就扩容到原来的两倍</span><br><span class="line">    if (++size &gt; threshold)</span><br><span class="line">        resize(); //double threshold</span><br><span class="line">    afterNodeInsertion(evict);</span><br><span class="line">    return null;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="resize扩容方法"><a href="#resize扩容方法" class="headerlink" title="resize扩容方法"></a>resize扩容方法</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br></pre></td><td class="code"><pre><span class="line">final Node&lt;K,V&gt;[] resize() &#123;</span><br><span class="line">    Node&lt;K,V&gt;[] oldTab = table;</span><br><span class="line">    int oldCap = (oldTab == null) ? 0 : oldTab.length;</span><br><span class="line">    int oldThr = threshold;</span><br><span class="line">    int newCap, newThr = 0;</span><br><span class="line">    //如果oldTab的长度不为空</span><br><span class="line">    if (oldCap &gt; 0) &#123;</span><br><span class="line">        //长度小于或等于最大的阈值则设置成最大的值</span><br><span class="line">        if (oldCap &gt;= MAXIMUM_CAPACITY) &#123;</span><br><span class="line">            threshold = Integer.MAX_VALUE;</span><br><span class="line">            return oldTab;</span><br><span class="line">        &#125;</span><br><span class="line">        //如果原来的长度*2小于最大的值并且大于默认的初始值。则将原来的长度扩容</span><br><span class="line">        //oldThr &lt;&lt; 1 扩容两倍</span><br><span class="line">        else if ((newCap = oldCap &lt;&lt; 1) &lt; MAXIMUM_CAPACITY &amp;&amp;</span><br><span class="line">                 oldCap &gt;= DEFAULT_INITIAL_CAPACITY)</span><br><span class="line">            newThr = oldThr &lt;&lt; 1; // double threshold</span><br><span class="line">    &#125;</span><br><span class="line">    //如果原来表的阈值大于0，则将新表的阈值设置为原来表的阈值</span><br><span class="line">    else if (oldThr &gt; 0) // initial capacity was placed in threshold</span><br><span class="line">        newCap = oldThr;</span><br><span class="line">    else &#123;               // zero initial threshold signifies using defaults</span><br><span class="line">        //如果小于0，则设置成默认，然后默认的负载因子*默认的初始容量</span><br><span class="line">        newCap = DEFAULT_INITIAL_CAPACITY;</span><br><span class="line">        newThr = (int)(DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY);</span><br><span class="line">    &#125;</span><br><span class="line">    //如果新表的阈值为0</span><br><span class="line">    if (newThr == 0) &#123;</span><br><span class="line">        //新的表的容量*负载因子，得到一个阈值</span><br><span class="line">        float ft = (float)newCap * loadFactor;</span><br><span class="line">        //如果新表的最大容量小于默认的最大容量，并且 阈值小于做大容量，则取ft,反之取最大</span><br><span class="line">        newThr = (newCap &lt; MAXIMUM_CAPACITY &amp;&amp; ft &lt; (float)MAXIMUM_CAPACITY ?</span><br><span class="line">                  (int)ft : Integer.MAX_VALUE);</span><br><span class="line">    &#125;</span><br><span class="line">    //将当前的阈值设为新表的阈值</span><br><span class="line">    threshold = newThr;</span><br><span class="line">    //抑制一些警告的关键字</span><br><span class="line">    @SuppressWarnings(&#123;&quot;rawtypes&quot;,&quot;unchecked&quot;&#125;)</span><br><span class="line">    //定义新表的容量</span><br><span class="line">        Node&lt;K,V&gt;[] newTab = (Node&lt;K,V&gt;[])new Node[newCap];</span><br><span class="line">        //将新表设置成当前的表</span><br><span class="line">    table = newTab;</span><br><span class="line">    //判断老的表是否为空</span><br><span class="line">    if (oldTab != null) &#123;</span><br><span class="line">        //循环老表</span><br><span class="line">        for (int j = 0; j &lt; oldCap; ++j) &#123;</span><br><span class="line">            Node&lt;K,V&gt; e;</span><br><span class="line">            //如果老表的这个地方不为null</span><br><span class="line">            if ((e = oldTab[j]) != null) &#123;</span><br><span class="line">                //先将老表的j处设置为null,等待GC回收</span><br><span class="line">                oldTab[j] = null;</span><br><span class="line">                //e为当前节点</span><br><span class="line">                //如果e的下一节点为null</span><br><span class="line">                if (e.next == null)</span><br><span class="line">                //就将e赋值给新表的</span><br><span class="line">                    newTab[e.hash &amp; (newCap - 1)] = e;</span><br><span class="line">                    //如果e是红黑树</span><br><span class="line">                else if (e instanceof TreeNode)</span><br><span class="line">                    ((TreeNode&lt;K,V&gt;)e).split(this, newTab, j, oldCap);</span><br><span class="line">                else &#123; // preserve order</span><br><span class="line">                    Node&lt;K,V&gt; loHead = null, loTail = null;</span><br><span class="line">                    Node&lt;K,V&gt; hiHead = null, hiTail = null;</span><br><span class="line">                    Node&lt;K,V&gt; next;</span><br><span class="line">                    do &#123;</span><br><span class="line">                        next = e.next;</span><br><span class="line">                        if ((e.hash &amp; oldCap) == 0) &#123;</span><br><span class="line">                            if (loTail == null)</span><br><span class="line">                                loHead = e;</span><br><span class="line">                            else</span><br><span class="line">                                loTail.next = e;</span><br><span class="line">                            loTail = e;</span><br><span class="line">                        &#125;</span><br><span class="line">                        else &#123;</span><br><span class="line">                            if (hiTail == null)</span><br><span class="line">                                hiHead = e;</span><br><span class="line">                            else</span><br><span class="line">                                hiTail.next = e;</span><br><span class="line">                            hiTail = e;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125; while ((e = next) != null);</span><br><span class="line">                    if (loTail != null) &#123;</span><br><span class="line">                        loTail.next = null;</span><br><span class="line">                        newTab[j] = loHead;</span><br><span class="line">                    &#125;</span><br><span class="line">                    if (hiTail != null) &#123;</span><br><span class="line">                        hiTail.next = null;</span><br><span class="line">                        newTab[j + oldCap] = hiHead;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return newTab;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> JAVA </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JAVA </tag>
            
            <tag> 源码 </tag>
            
            <tag> 集合 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Nginx简单操作</title>
      <link href="/Nginx%E7%AE%80%E5%8D%95%E6%93%8D%E4%BD%9C.html"/>
      <url>/Nginx%E7%AE%80%E5%8D%95%E6%93%8D%E4%BD%9C.html</url>
      
        <content type="html"><![CDATA[<p>前段时间刷知乎，看到两张图</p><p><img src="/Nginx简单操作/1.jpg" alt></p><p><img src="/Nginx简单操作/2.jpg" alt></p><p>这两幅图说明了正向代理和反向代理的区别</p><h3 id="正向代理"><a href="#正向代理" class="headerlink" title="正向代理"></a>正向代理</h3><p>你已知要去访问某台服务器，但是你不能直接去访问，你必须通过Proxy去访问，已知的就科学上网来说，你需要访问国外的网站，你直接访问不了，你需要搭一个服务器，通过服务器你才能去看外面的世界</p><h3 id="反向代理"><a href="#反向代理" class="headerlink" title="反向代理"></a>反向代理</h3><p>反向代理也就是说当你要去访问服务器的时候，你必须通过Proxy去访问，然后Proxy会通过随机算法将你的请求分发到指定的服务器，然后服务器返回给你你需要的资源，这里有一个区别就是，你不知道你需要访问的是哪一台服务器，你只能访问Proxy服务器，这个也可以理解为负载均衡</p><p>先看看本地的配置</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br></pre></td><td class="code"><pre><span class="line">#每行结尾要加上分号</span><br><span class="line">#user  nobody;#设定用户组</span><br><span class="line">worker_processes  1;</span><br><span class="line"></span><br><span class="line">#设置错误日志的路径，后面标识记录错误日志的级别</span><br><span class="line">#error_log  logs/error.log;</span><br><span class="line">#error_log  logs/error.log  notice;</span><br><span class="line">#error_log  logs/error.log  info;</span><br><span class="line">#指定nginx进程文件的地址</span><br><span class="line">#pid        logs/nginx.pid;</span><br><span class="line"></span><br><span class="line">#事件 </span><br><span class="line">events &#123;</span><br><span class="line">#use epoll;      #事件驱动模型，select|poll|kqueue|epoll|resig|/dev/poll|eventport</span><br><span class="line">#每个进程的最大连接数 worker_connections*worker_processes=max_connections</span><br><span class="line">    worker_connections  1024;#最大连接数，</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">http &#123;</span><br><span class="line">    include       mime.types;</span><br><span class="line">    default_type  application/octet-stream;</span><br><span class="line"></span><br><span class="line">    #log_format  main  &apos;$remote_addr - $remote_user [$time_local] &quot;$request&quot; &apos;</span><br><span class="line">    #                  &apos;$status $body_bytes_sent &quot;$http_referer&quot; &apos;</span><br><span class="line">    #                  &apos;&quot;$http_user_agent&quot; &quot;$http_x_forwarded_for&quot;&apos;;</span><br><span class="line"></span><br><span class="line">    #access_log  logs/access.log  main;</span><br><span class="line"></span><br><span class="line">    sendfile        on;</span><br><span class="line">    #tcp_nopush     on;</span><br><span class="line"></span><br><span class="line">    #keepalive_timeout  0;</span><br><span class="line">    keepalive_timeout  65;#连接的超时时间</span><br><span class="line"></span><br><span class="line">    #gzip  on;</span><br><span class="line">#设定负载均衡的服务器列表 myproject为列表的名字</span><br><span class="line">    upstream myproject &#123;  </span><br><span class="line">        #weigth参数表示权值，权值越高被分配到的几率越大 </span><br><span class="line">        #max_fails 当有#max_fails个请求失败，就表示后端的服务器不可用，默认为1，将其设置为0可以关闭检查 </span><br><span class="line">        #fail_timeout 在以后的#fail_timeout时间内nginx不会再把请求发往已检查出标记为不可用的服务器 </span><br><span class="line">        # backup 表示热备，表示当其他服务器发生事故时，才会启用那台热备的服务器</span><br><span class="line">        #这里指定多个源服务器，ip:端口,80端口的话可写可不写  </span><br><span class="line">        server 192.168.1.78:8080 weight=5 max_fails=2 fail_timeout=600s; </span><br><span class="line">        #server 192.168.1.222:8080 weight=3 max_fails=2 fail_timeout=600s backup;  </span><br><span class="line">    &#125; </span><br><span class="line">    server &#123;</span><br><span class="line">        listen       80;#监控的端口</span><br><span class="line">        server_name  localhost; #监控的地址 ，如果有多个主机名，则用空格隔开</span><br><span class="line"></span><br><span class="line">        #charset koi8-r;</span><br><span class="line">#服务日志</span><br><span class="line">        #access_log  logs/host.access.log  main;</span><br><span class="line"></span><br><span class="line">        # location / &#123;</span><br><span class="line">        #     root   html;</span><br><span class="line">        #     index  index.html index.htm;</span><br><span class="line">        # &#125;</span><br><span class="line"></span><br><span class="line">        #error_page  404              /404.html; </span><br><span class="line"></span><br><span class="line">        # redirect server error pages to the static page /50x.html</span><br><span class="line">        #</span><br><span class="line">        #错误日志，最后的是标识错误之后跳转到哪去</span><br><span class="line">        error_page   500 502 503 504  /50x.html;</span><br><span class="line">        #这里我是监控的本地localhost的80端口，然后代理到百度去了，挺简单的测试</span><br><span class="line">        location / &#123;</span><br><span class="line">            proxy_pass http://www.baidu.com;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        # proxy the PHP scripts to Apache listening on 127.0.0.1:80</span><br><span class="line">        #</span><br><span class="line">        #这里 location 后面加了正则表达式 会去匹配请求地址，然后如果匹配上则去请求proxy_pass后的服务器</span><br><span class="line">        #比如现在做的项目里面，有静态资源服务器，和处理请求的服务器，匹配的是.htm和.json会走不同的服务器</span><br><span class="line">        #location ~ \.php$ &#123;</span><br><span class="line">        #    proxy_pass   http://127.0.0.1;</span><br><span class="line">        #    deny 127.0.0.1;  #表示要拒绝的IP</span><br><span class="line">        # allow 172.18.5.54; #表示允许的IP</span><br><span class="line">        #&#125;</span><br><span class="line"></span><br><span class="line">        # pass the PHP scripts to FastCGI server listening on 127.0.0.1:9000</span><br><span class="line">        #</span><br><span class="line">        #location ~ \.php$ &#123;</span><br><span class="line">        #    root           html;</span><br><span class="line">        #    fastcgi_pass   127.0.0.1:9000;</span><br><span class="line">        #    fastcgi_index  index.php;</span><br><span class="line">        #    fastcgi_param  SCRIPT_FILENAME  /scripts$fastcgi_script_name;</span><br><span class="line">        #    include        fastcgi_params;</span><br><span class="line">        #&#125;</span><br><span class="line"></span><br><span class="line">        # deny access to .htaccess files, if Apache&apos;s document root</span><br><span class="line">        # concurs with nginx&apos;s one</span><br><span class="line">        #</span><br><span class="line">        #location ~ /\.ht &#123;</span><br><span class="line">        #    deny  all;</span><br><span class="line">        #&#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="谈一下负载均衡的调度算法"><a href="#谈一下负载均衡的调度算法" class="headerlink" title="谈一下负载均衡的调度算法"></a>谈一下负载均衡的调度算法</h3><h5 id="轮询算法："><a href="#轮询算法：" class="headerlink" title="轮询算法："></a>轮询算法：</h5><p>将用户的请求平均分配到web集群的每个节点，这个算法不会考虑每个节点的性能，所以一般用于每个节点性能一样的情况下</p><h5 id="权重算法："><a href="#权重算法：" class="headerlink" title="权重算法："></a>权重算法：</h5><p>给单个节点加权，使他被分配的几率提高</p><h5 id="ip-hash算法："><a href="#ip-hash算法：" class="headerlink" title="ip_hash算法："></a>ip_hash算法：</h5><p>根据用户的IP地址生成一个hash表，然后根据一样的IP地址分配到同一个服务器节点上，这样可以解决session共享的问题</p><h5 id="url-hash算法"><a href="#url-hash算法" class="headerlink" title="url_hash算法"></a>url_hash算法</h5><p>根据用户访问的url生成的hash表，使同一个url访问后端的同一个服务器</p><h5 id="fair"><a href="#fair" class="headerlink" title="fair"></a>fair</h5><p>根据后端响应的时间来分配请求，响应时间越快，则优先分配，意思是则优分配，需要下载nginx的upstream_fair模块</p>]]></content>
      
      
      <categories>
          
          <category> Nginx </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Nginx </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CAS 原理分析</title>
      <link href="/CAS%20%E5%8E%9F%E7%90%86%E5%88%86%E6%9E%90.html"/>
      <url>/CAS%20%E5%8E%9F%E7%90%86%E5%88%86%E6%9E%90.html</url>
      
        <content type="html"><![CDATA[<h1 id="CAS-原理分析"><a href="#CAS-原理分析" class="headerlink" title="CAS 原理分析"></a>CAS 原理分析</h1><h2 id="是什么？"><a href="#是什么？" class="headerlink" title="是什么？"></a>是什么？</h2><p> CAS（Compare and Swap）即比较并替换。是一种在多线程环境下面实现同步功能的技术，保证了多线程执行的安全性</p><h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><p>CAS 比较替换，通俗来讲，比较当前内存地址valueOffset当中的值是否和旧的预期值是否一样，如果一样，就进行替换，如果不一样，则重来，重新获取valueOffset内存地址当中的值，继续上述步骤，直到替换成功<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CAS(V,N,B)</span><br></pre></td></tr></table></figure></p><p>V：代表内存地址，即valueOffset<br>N: 代表内存地址的值<br>B: 代表需要去替换的值</p><p>当线程1获取到V内存地址下的值为1，则旧的预期N的值,此时线程1挂起<br>现在线程2也获取到了V内存地址下面的值为1，此时内存地址N的值为1，去替换成B的值，改成2,线程2结束<br>线程1重新开始运行，此时， 线程1获取到内存地址的值为2，去和旧的预期值1相比较，不相等，则CAS失败重复上述步骤，重新更新旧的预期值为2,当没有线程操作V内存地址下的值时，此时内存地址下的值2等于旧的预期值2，即修改成功</p><p>这里得说一下volatitle，用volatitle修饰的value值，保证了值在工作内存中的可见性，所以，当value值被修改之后,后面的线程能看到值被变更，才能去比较</p><h2 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h2><p>这里以原子操作类 <strong>Atomic系列</strong> 为例</p><p>Atomic系列主要有三个类来操作三种不同的值</p><ul><li>AtomicBoolean 操作bool值的原子类</li><li>AtomicInteger 操作Int值的原子类</li><li>AtomicLong 操作Long类型的原子类<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">/*</span><br><span class="line">这个是CAS的核心类，由于Java方法无法直接访问底层系统，需要通过本地（native）方法来访问Unsafe相当于一个后门，基于该类可以直接操作特定内存的数据。</span><br><span class="line">*/</span><br><span class="line">private static final Unsafe unsafe = Unsafe.getUnsafe();</span><br><span class="line">//valueOffset是表示该变量在内存地址中的偏移地址，因为unsafe就是根据内存偏移地址获取数据</span><br><span class="line">private static final long valueOffset;</span><br><span class="line"></span><br><span class="line">static &#123;</span><br><span class="line">    try &#123;</span><br><span class="line">        //通过unsafe的objectFieldOffset方法获取value值在内存中的偏移地址，通过偏移量，unsafe可以去操作该内存的value值</span><br><span class="line">        valueOffset = unsafe.objectFieldOffset</span><br><span class="line">            (AtomicInteger.class.getDeclaredField(&quot;value&quot;));</span><br><span class="line">    &#125; catch (Exception ex) &#123; throw new Error(ex); &#125;</span><br><span class="line">&#125;</span><br><span class="line">// value值使用了volatile 保证了value值在内存中的可见性</span><br><span class="line">private volatile int value;</span><br><span class="line"></span><br><span class="line">//设置一个值，并返回旧值</span><br><span class="line">public final int getAndSet(int newValue) &#123;</span><br><span class="line">    return unsafe.getAndSetInt(this, valueOffset, newValue);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 利用底层的CAS操作去比较替换值</span><br><span class="line">public final int getAndSetInt(Object var1, long var2, int var4) &#123;</span><br><span class="line">    int var5;</span><br><span class="line">    do &#123;</span><br><span class="line">        //获取到var2这个内存偏移量里面的值var5</span><br><span class="line">        var5 = this.getIntVolatile(var1, var2);</span><br><span class="line">        //然后下面的循环，会取到var2内存偏移量里面的值去和var5比较，如果相等将var4替换，如果不相等则继续循环</span><br><span class="line">    &#125; while(!this.compareAndSwapInt(var1, var2, var5, var4));</span><br><span class="line">    //返回 var5 为旧值</span><br><span class="line">    return var5;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h2 id="CAS缺陷"><a href="#CAS缺陷" class="headerlink" title="CAS缺陷"></a>CAS缺陷</h2><p>　　最明显的缺陷就是ABA问题</p><p>当有三个线程 第一个线程将值改为1 挂起。第二个线程 将值改为2 结束。第三个线程又将值改为1 结束。此时第一个线程跑起来，去比较替换，发现内存中的值还是为1 此时替换成功。</p><p>这个看起来没有什么问题，但是在特殊场景下面，会出现麻烦。</p><p>比如：一个库存操作，库存100个 两个线程同时出库50个，此时第二次线程是误操作，应该只有第一次提取成功，将100元改成50.此时第二线程挂起，有人入库了50个，此时库存为100，则第二线程继续执行，发现库存还是100，则修改库存为50，此时库存为100，但是第一线程出库之后应该只有50，此时库存为100，则出现异常</p><p>　 <strong>解决方案</strong></p><ul><li>AtomicStampedReference原子类是一个带有时间戳的对象引用，在每次修改后，AtomicStampedReference不仅会设置新值而且还会记录更改的时间。当AtomicStampedReference设置对象值时，对象值以及时间戳都必须满足期望值才能写入成功，这也就解决了反复读写时，无法预知值是否已被修改的窘境</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">//构造函数会包含一个时间戳去记录</span><br><span class="line">private static class Pair&lt;T&gt; &#123;</span><br><span class="line">    final T reference;</span><br><span class="line">    final int stamp;</span><br><span class="line">    private Pair(T reference, int stamp) &#123;</span><br><span class="line">        this.reference = reference;</span><br><span class="line">        this.stamp = stamp;</span><br><span class="line">    &#125;</span><br><span class="line">    static &lt;T&gt; Pair&lt;T&gt; of(T reference, int stamp) &#123;</span><br><span class="line">        return new Pair&lt;T&gt;(reference, stamp);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">//在设置CAS的操作过程中去调用casPair方法</span><br><span class="line">public boolean compareAndSet(V   expectedReference,</span><br><span class="line">                             V   newReference,</span><br><span class="line">                             int expectedStamp,</span><br><span class="line">                             int newStamp) &#123;</span><br><span class="line">    Pair&lt;V&gt; current = pair;</span><br><span class="line">    return</span><br><span class="line">        expectedReference == current.reference &amp;&amp;</span><br><span class="line">        expectedStamp == current.stamp &amp;&amp;</span><br><span class="line">        ((newReference == current.reference &amp;&amp;</span><br><span class="line">          newStamp == current.stamp) ||</span><br><span class="line">         casPair(current, Pair.of(newReference, newStamp)));</span><br><span class="line">&#125;</span><br><span class="line">//此时也是用的unsafe方法调用的compareAndSwapObject方法</span><br><span class="line">private boolean casPair(Pair&lt;V&gt; cmp, Pair&lt;V&gt; val) &#123;</span><br><span class="line">    return UNSAFE.compareAndSwapObject(this, pairOffset, cmp, val);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p> 其实CAS就是无锁编程的一种实现，也是一个乐观锁，在任何情况下，都认为事情都是往好的一方面发展，当线程发现冲突时，则利用CAS去保证线程的安全性，这就是CAS实现无锁策略的核心所在</p>]]></content>
      
      
      <categories>
          
          <category> JAVA </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JAVA </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
